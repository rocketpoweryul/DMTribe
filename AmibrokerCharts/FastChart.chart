<?xml version="1.0" encoding="UTF-8"?>
<Window>
	<Sheet>
		<Name>Sheet 1</Name>
		<Pane>
			<ChartID>1045</ChartID>
			<PercentHeight>83.7748</PercentHeight>
			<Formula>// THIS IS NOT FORMAL CODE\r\n\r\n// This file is a chart formula for Amibroker\r\n// The purpose is to test detection of chart characteristics driven by the function library\r\n\r\n// include the functional library\r\n#include &lt;TPT_Func_Lib.afl&gt;\r\n\r\n// price plots\r\n\r\nTick = Name();\r\n\r\ndispflag = StaticVarGet("dispflag");\r\n\r\n// GUI\r\nPDon = 1;\r\nGuiButton("PD ON", PDon, 0, 15, 50, 20, notifyClicked);\r\n\r\nPDoff = 2;\r\nGuiButton("PD OFF", PDoff, 55, 15, 50, 20, notifyClicked);\r\n\r\n\r\nif ( GuiGetEvent(0,0) ==1 )\r\n\tdispflag = True;\r\n\r\nif ( GuiGetEvent(0,0) ==2 )\r\n\tdispflag = False;\r\n\t\r\nStaticVarSet("dispflag", dispflag);\r\n\r\nIntStkBut = 3;\r\nGuiButton("Add to IS", IntStkBut, 0, 45, 65, 20, notifyClicked);\r\n\r\nif ( GuiGetEvent(0,0) ==3 )\r\n\t{\r\n\t\tIntStock = CategoryFind("Interesting Stocks", categoryWatchlist);\r\n\t\tCategoryAddSymbol(Tick, categoryWatchlist, IntStock);\r\n\t}\r\n\r\nSqStkBut = 4;\r\nGuiButton("Add to Sq", SqStkBut, 70, 45, 65, 20, notifyClicked);\r\n\r\nif ( GuiGetEvent(0,0) ==4 )\r\n\t{\r\n\t\tSqStock = CategoryFind("Squeezes", categoryWatchlist);\r\n\t\tCategoryAddSymbol(Tick, categoryWatchlist, SqStock);\r\n\t}\r\n\r\n\r\n/*\r\n// REWIND CODE\r\n_SECTION_BEGIN("Rewind");\r\n{\r\n\t// Set rewind bars\r\n\tNowDate\t\t= Now(1);\r\n\tRewindDate \t= ParamDate("Rewind to:", NowDate, 1);\r\n\t\r\n// \tDEBUG - use this when debugging the forumla as the chart parameter window has no effect\r\n//\tComment out when not needed\r\n//RewindDate = "3/12/2021";\r\n//\r\n\t\t\r\n\t// from Amibroker forum (code taken directly from Tomasz post on how to use Lookup\r\n\tbi = BarIndex();\r\n\tRewindBars =  Lookup( bi, _DT(NowDate), -1 ) - Lookup( bi, _DT( RewindDate), -1 );\r\n\t\r\n\t// set new OHLC arrays\r\n\tL = Ref(L, -RewindBars);\r\n\tH = Ref(H, -RewindBars);\r\n\tC = Ref(C, -RewindBars);\r\n\tO = Ref(O, -RewindBars);\r\n}\r\n_SECTION_END();\r\n*/\r\n\r\n_SECTION_BEGIN("Price");\r\n{\r\n\r\n\t//plot chart data\r\n\tthickness = Param( "Bar thickness", -20, -100, 10, 1 );\r\n\t\r\n\trc = ROC( C, 1 );\r\n\tcolor = IIf( rc &gt;= 0, colorBlue, IIf( rc &lt; 0, colorRed, -1 ) );\r\n\t\r\n\tstyle = styleNoTitle | styleBar;\r\n\t\r\n\tSetChartOptions( 0, chartShowArrows | chartShowDates );\r\n\r\n\t\r\n\tPlotOHLC(O, H, L, C, "", color, style, Null, Null, 0, 0, thickness ); \r\n\t\t\r\n\t_N(Title = StrFormat("{{NAME}} - {{INTERVAL}} {{DATE}} Open %g, Hi %g, Lo %g, Close %g (%.1f%%)", O, H, L, C, SelectedValue( ROC( C, 1 ) ) ));\r\n\t\r\n\t// plot MAs and RS Line\r\n\tSMA200 = MA(C, 200);\r\n\tSMA150 = MA(C, 150);\r\n\tSMA050 = MA(C,  50);\r\n\tSMA020 = MA(C,  20);\r\n\tSMA010 = MA(C,  10);\r\n\tSMA005 = MA(C,   5);\r\n\t\r\n\tPlot(SMA200, "200D SMA", colorBlack);\r\n\t//PlotText("200dSMA", BarCount+2, LastValue(SMA200), colorBlack);\r\n\tPlot(SMA150, "150D SMA", colorBlue );\r\n\t//PlotText("150dSMA", BarCount+2, LastValue(SMA150), colorBlue);\r\n\tPlot(SMA050, "50D SMA" , colorRed  );\r\n\t//PlotText("50dSMA", BarCount+2, LastValue(SMA050), colorRed);\r\n\tPlot(SMA020, "20D SMA" , colorGreen);\r\n\t//PlotText("20dSMA", BarCount+2, LastValue(SMA020), colorGreen);\r\n\t//Plot(SMA010, "10D SMA" , colorDarkYellow);\r\n\t//Plot(SMA005, "5D SMA"  , colorBrown);\r\n}\r\n_SECTION_END();\t\r\n\r\n_SECTION_BEGIN("RS Line");\r\n{\r\nRSL = C/Foreign("$SPX", "C")*1500;\r\nBuy = false;\r\nBuy[BarCount-2] = true;\r\nRSLHigh \t\t= ExRem(RSL == HHV(RSL, 69), Buy);\r\nrslb\t\t\t= RSL + C[BarCount-1]/2.25;\r\nPlotShapes(IIf(RSLHigh, shapeCircle, shapeNone), colorAqua, 0, rslb, 0);\r\nPlot(rslb, "RS Line", colorBlue, styleDashed);\r\nPlotText("RS Line", BarCount+2, LastValue(rslb), colorBlue);\r\n}\r\n_SECTION_END();\r\n\r\n_SECTION_BEGIN("Hourly Pivot Hgih");\r\n{\r\n\thourpivot = Param("Hourly Pivot High", 0, LastValue(C), 1e5, 0.01);\r\n}\r\n\r\n// determine RS\r\nRS = StaticVarGet("RS_" + Name());\r\nRSref = LastValue(HHV(rslb, 21*6));\r\nRScurve = RS/99*RSref*0.28+LastValue(C)*0.6;\r\nPlot(RScurve, "RS Curve", colorGrey50, styleDashed);\r\nPlotText("RS Curve", BarCount+2, LastValue(RScurve), colorBlack);\r\n\r\n\r\n///// DEBUG CODE: FUNCTION TEST CODE (EMPTY IF NO FUNCTIONAL UNIT TESTS BEING PERFORMED)\r\n\r\n\r\n/////\r\n\r\n// DEBUG CODE: BLUE AND GOLD ARROW PLOTS\r\nenabledebugarrow = 0;\r\nif(enabledebugarrow)\r\n{\r\n\t//PlotShapes(IIf(SwingLow(L),  shapeUpArrow,   shapeNone), colorOrange, 0, Graph0Low,  -25);\r\n\t//PlotShapes(IIf(SwingHigh(H), shapeDownArrow, shapeNone), colorOrange, 0, Graph0High, -25);\r\n\t\r\n\tConIndex = getContractionIndex( L, H, O, C );\t\r\n\tSH \t\t = SwingHigh( H );\r\n\t\r\n\ti = 1;\r\n\tHOBBars = LastValue(HHVBars(H, 130));\r\n\tHOB     = LastValue(HHV(    H, 130));\r\n\t\r\n\t\r\n\tdo\r\n\t{\r\n\tCurLow = LowestLow(L, H, O, C, SH, i);\r\n\tLowCond  = L == CurLow;\r\n\tPlotShapes(IIf(LowCond, shapeUpArrow, shapeNone), colorBlue, 0, Graph0Low, -40);\r\n\t\r\n\tCurHigh = HighestHigh(H, SH, i);\r\n\tHighCond = H == CurHigh;\r\n\tPlotShapes(IIf(HighCond AND SH, shapeDownArrow, shapeNone), colorBlue, 0, Graph0High, -40);\r\n\t\r\n\ti++;\r\n\tSHBars = SwingIndex(SH, i);\r\n\t}\r\n\twhile(SHBars &lt;= HOBBars);\r\n\r\n\ti = 1;\r\n\tdo\r\n\t{\r\n\tCurLow = LowestLow(L, H, O, C, ConIndex, i);\r\n\tLowCond  = L == CurLow;\r\n\tPlotShapes(IIf(LowCond, shapeUpArrow, shapeNone), colorDarkYellow, 0, Graph0Low, -40);\r\n\t\r\n\tCurHigh = HighestHigh(H, ConIndex, i);\r\n\tHighCond = H == CurHigh;\r\n\tPlotShapes(IIf(HighCond AND ConIndex, shapeDownArrow, shapeNone), colorDarkYellow, 0, Graph0High, -40);\r\n\t\r\n\ti++;\r\n\tSHBars = SwingIndex(ConIndex, i);\r\n\t}\r\n\twhile(SHBars &lt;= HOBBars);\t\r\n\t\r\n}\r\n\r\n// STOCK ANALYSIS CODE\r\n{\t\r\n\t// init pivot data\r\n\tPvtVld \t\t= False;\r\n\tPvtIndex\t= 0;\r\n\tPvtPrice\t= 0;\r\n\tLHSBars\t\t= BarCount;\r\n\tPvtH\t\t= 0;\r\n\tPrevH\t\t= 0;\r\n\tOvlp \t\t= 0;\r\n\tTurnLA \t\t= Null;\r\n\tPPPvtVld\t= 0;\r\n\tDepth \t\t= Null;\r\n\t\r\n\tIPO = BarCount &lt; 21*12;\r\n\t\r\n\t// find a valid base\r\n\tVldCSBase  \t= False;\r\n\tVldCapBase  = False;\r\n\tVldPPBase   = False;\r\n\t\r\n\t\t\r\n\t// determine if trending\r\n\tTF = TrendFilter(L, H, O, C, V);\r\n\t\r\n\tif (StrMatch(StaticVarGetText("ChartRefresh"), Tick))\r\n\t{\r\n\t\tVldPPBase = StaticVarGet("_VldPPBAse");\r\n\t\tVldCSBase = StaticVarGet("_VldCSBase");\r\n\t\tVldCapBase = StaticVarGet("_VldCapBase");\r\n\t}\r\n\telse\r\n\t{\r\n\t\tVldPPBase\t\t= getPPBaseParam(     L, H,\t      "Validity"   );\r\n\t\t\t\r\n\t\tif (NOT VldPPBase)\r\n\t\t\tVldCSBase  \t= getCSBaseParam(     L, H, O, C, "Validity"   );\r\n\t\t\r\n\t\tif (NOT VldCSBase)\r\n\t\t\tVldCapBase  = getCSCapBaseParam(  L, H, O, C, "Validity"   );\r\n\t\t\t\r\n\t\tif (VldPPBase) StaticVarSet("_VldPPBAse", VldPPBase);\r\n\t\telse StaticVarSet("_VldPPBAse", False);\r\n\t\t\r\n\t\tif (VldCSBase) StaticVarSet("_VldCSBase", VldCSBase);\r\n\t\telse StaticVarSet("_VldCSBase", False);\r\n\t\t\r\n\t\tif (VldCapBase) StaticVarSet("_VldCapBase", VldCapBase);\r\n\t\telse StaticVarSet("_VldCapBase", False);\r\n\t}\r\n\t\r\n\t// get and plot data depending on base type or else do nothing\r\n\r\n\tif (VldCapBase)\r\n\t{\r\n\t\t// get params\r\n\t\tCapValues  \t= getCSCapBaseParam( L, H, O, C, "Values"\t);\r\n\t\t\r\n\t\tLHSPrice \t= CapValues[0];\r\n\t\tLHSBars\t\t= CapValues[1];\r\n\t\tLowPrice \t= CapValues[2];\r\n\r\n\t\tLowBar \t\t= IIf(BarIndex()&gt; BarCount - CapValues[1] -1, LowPrice, Null);\r\n\t\tHighBar\t\t= IIf(BarIndex()&gt; BarCount - CapValues[1] -1, LHSPrice, Null);\r\n\r\n\t\tPlot(LowBar , "LowBar" , colorTeal, styleThick);\r\n\t\tPlot(HighBar, "HighBar", colorTeal, styleThick);\r\n\t\t\r\n\t\tDepth = (1 - LowPrice/LHSPrice)*100;\r\n\t\t\r\n\t}\r\n\r\n\tif (VldCSBase)\r\n\t{\r\n\t\t// get params\r\n\t\tLHSPrice  \t= getCSBaseParam( L, H, O, C, "LHSPrice"\t);\r\n\t\tLHSBars  \t= getCSBaseParam( L, H, O, C, "LHSBars"\t\t);\r\n\t\tLowPrice  \t= getCSBaseParam( L, H, O, C, "LowPrice"\t);\r\n\r\n\t\tLowBar \t\t= IIf(BarIndex()&gt; BarCount - LHSBars -1, LowPrice, Null);\r\n\t\tHighBar\t\t= IIf(BarIndex()&gt; BarCount - LHSBars -1, LHSPrice, Null);\r\n\t\t\r\n\t\tPlot(LowBar , "LowBar" , colorTeal, styleThick);\r\n\t\tPlot(HighBar, "HighBar", colorTeal, styleThick);\r\n\t\t\r\n\t\tDepth = (1 - LowPrice/LHSPrice)*100;\r\n\t}\r\n\t\r\n\tif (VldPPBase)\r\n\t{\r\n\t\t// get params\r\n\t\tLHSPrice  \t= getPPBaseParam( L, H, "PoleHigh"\t);\r\n\t\tLowPrice  \t= getPPBaseParam( L, H, "FlagLow"\t);\r\n\r\n\t\tLHSBars  \t= getPPBaseParam( L, H, "PHBar"\t\t);\r\n\t\tPoleLow  \t= getPPBaseParam( L, H, "PoleLow"\t);\r\n\t\tPoleLen  \t= getPPBaseParam( L, H, "PoleLen"\t);\r\n\r\n\t\tFlagLowLine \t= IIf(BarIndex()&gt; BarCount - LHSBars -1, LowPrice , Null);\r\n\t\tFlagHighLine\t= IIf(BarIndex()&gt; BarCount - LHSBars -1, LHSPrice, Null);\r\n\t\t\r\n\t\tPoleLine\t\t= LineArray(BarCount - PoleLen - LHSBars, PoleLow, BarCount - LHSBars, LHSPrice);\r\n\t\t\t\t\r\n\t\tPlot(FlagLowLine , "LowBar"  , colorTeal, styleThick);\r\n\t\tPlot(FlagHighLine, "HighBar" , colorTeal, styleThick);\r\n\t\tPlot(PoleLine,\t   "PoleLine", colorTeal, styleThick); \r\n\t\t\r\n\t\tDepth = (1 - LowPrice/LHSPrice)*100;\r\n\r\n\t}\r\n\t\r\n\t/*\r\n\tif (Depth &gt; 15 AND (VldCSBase OR VldCapBase OR VldPPBase))\r\n\t{\r\n\t\tTurnLA = getTurnLA(L, H, O, C);\r\n\t\t\t\r\n\t\t// format turn for plotting\r\n\t\tTurnLAPlot = IIf(TurnLA &gt; 1.01*LHSPrice, Null, TurnLA);\r\n\t\tTurnLAPlot = IIf(TurnLA &lt; 0.99*LowPrice, Null, TurnLA);\r\n\t\t\t\r\n\t\tPlot(TurnLAPlot, "TurnLA", colorBrown, styleThick);\r\n\t}\r\n\t*/\r\n\t\r\n\t\r\n\t// get and plot pivot data if there is a valid base\r\n\tif (True)//VldCSBase OR VldCapBase OR VldPPBase)\r\n\t{\r\n\t\t// get contraction index\r\n\t\tConIndex = getContractionIndex( L, H, O, C );\r\n\t\tsumcon   = LastValue(Sum(ConIndex, BarCount));\r\n\r\n\t\tPvtVld \t\t= getMSPivotParam( L, H, O, C, "Validity"       );\r\n\t\tPvtIndex\t= getMSPivotParam( L, H, O, C, "SwingHighIndex" );\r\n\t\tPvtPrice\t= getMSPivotParam( L, H, O, C, "Price" \t\t\t);\r\n\t\t\r\n\t\tVolOK \t\t= checkVolume(C, V, ConIndex, LHSBars);\r\n\t\t\r\n\t\t// plot contraction size at contractions\r\n\t\tPPH\t  = Height(L, H, O, C, ConIndex, PvtIndex[0], PvtIndex[1]);\r\n\t\tPvtH  = Height(L, H, O, C, ConIndex, PvtIndex[2], PvtIndex[3]);\r\n\t\tPrevH = Height(L, H, O, C, ConIndex, PvtIndex[4], PvtIndex[5]);\r\n\r\n\t\t// plot green arrows at contractions\r\n\t\tPPLow    = PvtPrice[0];\r\n\t\tPPHigh   = PvtPrice[1];\r\n\t\tPvtLow   = PvtPrice[2];\r\n\t\tPvtHigh  = PvtPrice[3];\r\n\t\tPrevLow  = PvtPrice[4];\r\n\t\tPrevHigh = PvtPrice[5];\r\n\t\t\r\n\t\t//look for possible hourly pivot or at the turn pivot\r\n\t\tif (VldPPBAse AND NOT PvtVld)\r\n\t\t{\r\n\t\t\tPPPvtVld = getPPPivotParam(L, H, C, V, LowPrice, LHSPrice, TurnLA, PvtH, PvtPrice[1]);\r\n\t\t}\r\n\t\t\r\n\t\t// pause pivot arrow\r\n\t\tPPCond = isPausePivot(L,H,O,C, ConIndex);\r\n\t\t\r\n\t\t// text output pivot and stops\r\n\t\tif ( ( PvtVld OR PPPvtVld == 2 OR (PPPvtVld == 1 AND hourpivot == 0 ) ) AND NOT PPCond  AND dispflag)\r\n\t\t{\t\r\n\t\t\tpivotprice = "BP:   $" + NumToStr( PvtHigh + 0.1, \t\t8.2, False);\r\n\t\t\tlimitprice = "Lim: $"  + NumToStr((PvtHigh + 0.1)*1.01, 8.2, False);\r\n\t\t\tPlotText(pivotprice, BarCount+1, PvtHigh + 0.1, colorGreen, 0, 0);\r\n\t\t\tPlotText(limitprice, BarCount+1, (PvtHigh + 0.1)*1.01, colorGreen, 0, 10);\r\n\t\t\t\r\n\t\t\tstop2 = "2% STP: $" + NumToStr((PvtHigh + 0.1)*0.98, 8.2, False);\r\n\t\t\tstop4 = "4% STP: $" + NumToStr((PvtHigh + 0.1)*0.96, 8.2, False);\r\n\t\t\tPlotText(stop2, BarCount+1, (PvtHigh + 0.1)*0.98, colorGreen, 0, 0);\r\n\t\t\tPlotText(stop4, BarCount+1, (PvtHigh + 0.1)*0.96, colorGreen, 0, 0);\r\n\t\t}\r\n\t\telse if ( PPPvtVld == 1 AND hourpivot &gt; 0)\r\n\t\t{\r\n\t\t\tpivotprice = "BP:   $" + NumToStr(  hourpivot + 0.1, \t   8.2, False);\r\n\t\t\tlimitprice = "Lim: $"  + NumToStr( (hourpivot + 0.1)*1.01, 8.2, False);\r\n\t\t\tPlotText(pivotprice, BarCount+1, hourpivot + 0.1, colorGreen, 0,   0\t );\r\n\t\t\tPlotText(limitprice, BarCount+1, (hourpivot + 0.1)*1.01, colorGreen, 0,   10 );\r\n\t\t\t\r\n\t\t\tstop2 = "2% STP: $" + NumToStr((hourpivot + 0.1)*0.98, 8.2, False);\r\n\t\t\tstop4 = "4% STP: $" + NumToStr((hourpivot + 0.1)*0.96, 8.2, False);\r\n\t\t\tPlotText(stop2, BarCount+1, (hourpivot + 0.1)*0.98, colorGreen, 0, 0);\r\n\t\t\tPlotText(stop4, BarCount+1, (hourpivot + 0.1)*0.96, colorGreen, 0, 0);\r\n\t\t}\r\n\t\telse if ( PPCond AND PvtVld)\r\n\t\t{\r\n\t\t\tpivotprice = "BP:   $" + NumToStr( LastValue(H) + 0.1, \t\t8.2, False);\r\n\t\t\tlimitprice = "Lim: $"  + NumToStr( (LastValue(H) + 0.1)*1.01,     8.2, False);\r\n\t\t\tPlotText(pivotprice, BarCount+1, LastValue(H) + 0.1, colorGreen, 0, 0);\r\n\t\t\tPlotText(limitprice, BarCount+1, (LastValue(H) + 0.1)*1.01, colorGreen, 0, 10);\r\n\t\t\t\r\n\t\t\tstop2 = "2% STP: $" + NumToStr((LastValue(H) + 0.1)*0.98, 8.2, False);\r\n\t\t\tstop4 = "4% STP: $" + NumToStr((LastValue(H) + 0.1)*0.96, 8.2, False);\r\n\t\t\tPlotText(stop2, BarCount+1, (LastValue(H) + 0.1)*0.98, colorGreen, 0, 0);\r\n\t\t\tPlotText(stop4, BarCount+1, (LastValue(H) + 0.1)*0.96, colorGreen, 0, 0);\r\n\t\t}\r\n\t\t\t\t\r\n\t\tCondH = (H == PvtHigh OR H == PrevHigh OR H == PPHigh) AND ConIndex;\r\n\t\t\t\t\r\n\t\tif (PvtIndex[1] == 0)\r\n\t\t\tCondH[BarCount-1] = True;\r\n\t\t\r\n\t\tCondLPP  = BarIndex() == BarCount - 1 AND PPCond;\r\n\t\tCondLPvt = BarIndex() &gt;= BarCount - SwingIndex(ConIndex, PvtIndex[2]) -1 AND L == PvtLow;\r\n\t\tCondLPrv = BarIndex() &gt;= BarCount - SwingIndex(ConIndex, PvtIndex[4]) -1 AND BarIndex() &lt;= BarCount - SwingIndex(ConIndex, PvtIndex[2]) + 1 AND L == PrevLow AND NOT IsNull(PrevH);\r\n\t\t\r\n\t\tCondL = CondLPP OR CondLPvt OR CondLPrv;\r\n\t\t\r\n\t\tif (dispflag)\r\n\t\t{\r\n\t\t\tPlotShapes(IIf(CondH, shapeDownArrow, shapeNone), colorGreen, 0, Graph0High, -40);\r\n\t\t\tPlotShapes(IIf(CondL, shapeUpArrow,   shapeNone), colorGreen, 0, Graph0Low , -40);\r\n\t\t\r\n\t\t\tPlotShapes(IIf(BarIndex() == BarCount -1 AND PPPvtVld == 1, shapeDownArrow, shapeNone), colorOrange, 0, Graph0High , -40);\r\n\t\t}\r\n\r\n\t}\r\n\t\r\n\t//////////////////////////////////\r\n\t// Price Dispersion code\r\n\t{\r\n\t\t// calculate regression parameters for tuneable range\r\n\t\tLRdays = 5;\r\n\t\t\r\n\t\t// calculate middle of bar\r\n\t\tPDID   = (H-L)/2 + L;\r\n\t\t\r\n\t\tPDInt  = LastValue(LinRegIntercept(PDID, LRdays));\r\n\t\tPDSlp  = LastValue(LinRegSlope(    PDID, LRdays));\r\n\t\t\r\n\t\t// calculate regression line\r\n\t\tPDx    = Cum(1);\r\n\t\tPDline = PDSlp*(PDx - (LastValue(PDx - LRdays))) + PDInt;\r\n\t\t\r\n\t\t// calculate the absolute value of the difference from the high and low to the regression line in percent\r\n\t\tPDdH = abs(H - PDLine)/PDLine;\r\n\t\tPDdL = abs(L - PDLine)/PDLine;\r\n\t\t\r\n\t\t// calculate the dispersion (array-based)\r\n\t\tPriceDisp = (Sum(PDdH, LRdays) + Sum(PDdL, LRdays))/(LRdays*2);\r\n\t\t\r\n\t\t//plot dispersion line\r\n\t\tPDLPlot = PDLine;\r\n\t\tPDLPlot =IIf(BarIndex() &lt; BarCount-5, Null, PDLPlot);\r\n\t\t\t\r\n\t\t//Plot(PDLPlot, "Price Disperson Line", colorTeal, styleThick);\r\n\t\t\r\n\t}\t\r\n}\r\n\r\n// LOW-LEVEL GRAPHICS OVERLAY CODE\t\r\nenable = 1;\r\n_SECTION_BEGIN("Text spacing");\r\n{\r\n\tstrt   = Param("Info Field Bias", 10);\r\n\tinc\t   = Param("Text Spacing", 20);\r\n\t\r\n}\r\n_SECTION_END();\r\n\r\n// in watchlist\r\n\r\n\tListNum = CategoryFind( "Interesting Stocks", categoryWatchlist );\r\n\tGfxSetBkMode( 1 );\r\n\tGfxSetBkMode( 2 );\r\n\tGfxSetBkColor( colorWhite );\r\n\tGfxSelectFont("Calibri", 18, 1000, False, False, 0);\r\n\tGfxSetTextColor(colorIndigo);\r\n\tWLstar = WriteIf(InWatchList(ListNum), "*", "");\r\n\tGfxTextOut( WLstar, 40, 70);\r\n\r\n\tListNum = CategoryFind( "Squeezes", categoryWatchlist );\r\n\tGfxSelectFont("Calibri", 14, 1000, False, False, 0);\r\n\tWLS = WriteIf(InWatchList(ListNum), "S", "");\r\n\tGfxTextOut( WLS, 40, 90);\r\n\r\n// Ticker\r\n\tGfxSelectFont("Calibri", 60, 1000, False, False, 0);\r\n\tthecolor = iif(ROC(C,1)&gt;0, colorLime, colorRed);\r\n\tGfxSetTextColor(thecolor[BarCount-1]);\r\n\tGfxTextOut( Name(), 60, 50);\r\n\r\n// GICS\r\n\tGfxSetTextColor(colorViolet);\r\n\tGfxSelectFont("Calibri", 12, 1000, False, False, 0);\r\n\tGfxTextOut(GicsID(1), 65, 120 + strt);\r\n\r\n// RS\r\n\tGfxSelectFont("Calibri", 20, 1000, False, False, 0);\r\n\tRStext = WriteIf(NOT IPO AND IsNull(RS), "N/A", "N/A");\r\n\tRStext = WriteIf(IPO, "IPO", NumToStr(RS,1));\r\n\tthecolor = iif(RS&gt;89, colorLime, IIf(StrMatch(RStext, "N/A"), colorDarkYellow, colorRed));\r\n\tGfxSetTextColor(thecolor[BarCount-1]);\r\n\t\t\r\n\tGfxTextOut("RS: " + RStext, 65, 140 + strt);\r\n\t\r\n\t\trowval = 170+strt;\r\n\t\t\r\nif ( dispflag) // Ticker and VCP graphics code\r\n{\t\r\n\t// detailed data\r\n\t\r\n\t// start row value\r\n\r\n\tGfxSelectFont("Calibri", 14, 1000, False, False, 0);\r\n\t\r\n\t// Trending data\r\n\tTrend = WriteIf(LastValue(TF), "Stage 2 Uptrend", "Not in Stage 2 Uptrend");\r\n\tthecolor = IIf(TF, colorLime, colorRed);\r\n\tGfxSetTextColor(thecolor[BarCount-1]);\r\n\tGfxTextOut(Trend, 65, rowval);\r\n\trowval += inc;\r\n\t\r\n\t// Base, contraction and pivot data\r\n\tBase = WriteIf(VldCapBase, "Valid Cap Base", WriteIf(VldCSBase, "Valid CS Base", WriteIf(VldPPBase, "Valid PS Base", "Invalid Base")));\r\n\tthecolor = iif(StrMatch("Valid CS Base", Base) OR StrMatch("Valid Cap Base", Base) OR StrMatch("Valid PS Base", Base), colorLime, colorRed);\r\n\tGfxSetTextColor(thecolor[BarCount-1]);\r\n\tGfxTextOut(Base, 65, rowval);\r\n\trowval += inc;\r\n\t\r\n\t// Base len\r\n\tif (VldCapBase OR VldCSBase OR VldPPBase)\r\n\t{\r\n\t\tthecolor = colorDarkYellow;\r\n\t\tGfxSetTextColor(thecolor[BarCount-1]);\r\n\t\tGfxTextOut("Base Length: " + NumToStr(LHSBars, 1.0) + " bars", 65, rowval);\r\n\t\trowval += inc;\r\n\t}\r\n\t\r\n\tPvt = WriteIf(PvtVld, "Valid Classic Pivot", WriteIf(PPPvtVld == 2, "Valid PS Pivot", WriteIf(PPPvtVld == 1, "Possible Hourly PS Pivot", "Invalid Pivot")));\r\n\tPvt = WriteIf(hourpivot &gt; 0, "Hourly PS Pivot", Pvt);\r\n\t\r\n\tthecolor = iif(StrMatch("Valid Classic Pivot", Pvt) OR StrMatch("Valid PS Pivot", Pvt) OR StrMatch("Hourly PS Pivot", Pvt), colorLime, IIf(StrMatch("Possible Hourly PS Pivot", Pvt), colorOrange, colorRed));\r\n\tGfxSetTextColor(thecolor[BarCount-1]);\r\n\tGfxTextOut(Pvt, 65, rowval);\r\n\trowval += inc;\r\n\t\r\n\t// pause pivot\r\n\tif (PPCond AND (PvtVld OR PPPvtVld == 1) AND NOT (PPPvtVld = 1 AND hourpivot &gt; 0))\r\n\t{\r\n\tPvtStr = "Pause Pivot Con: "    + WriteIf(IsNull(PPH), "N/A", NumToStr(PPH,  1.1) + "%");\r\n\tthecolor = iif(PPH &lt;= 8, colorGreen, IIf(PPPvtVld == 1, colorOrange, colorRed));\r\n\tGfxSetTextColor(thecolor[BarCount-1]);\r\n\tGfxTextOut(PvtStr, 80, rowval);\r\n\trowval += inc;\r\n\t}\r\n\t\r\n\tPvtStr = "PvtCon: "    + WriteIf(IsNull(PvtH), "N/A", NumToStr(PvtH,  1.1) + "%");\r\n\tPvtGood = IIf(PPCond, 10.05, 6.55);\r\n\tthecolor = iif(PvtH &lt;= PvtGood OR (VldPPBase AND PvtH &lt; 8.05), colorLime, IIf(PPPvtVld == 1, colorOrange, IIf(PPCond, colorDarkYellow, colorRed)));\r\n\tGfxSetTextColor(thecolor[BarCount-1]);\r\n\tGfxTextOut(PvtStr, 80, rowval);\r\n\trowval += inc;\r\n\t\r\n\tPrvStr = "PrvCon: "    + WriteIf(IsNull(PrevH), "N/A", NumToStr(PrevH, 1.1) + "%");\r\n\tthecolor = iif(PPPvtVld &gt; 0 OR PrevH &lt;= 16, colorLime, colorDarkYellow);\r\n\tGfxSetTextColor(thecolor[BarCount-1]);\r\n\tGfxTextOut(PrvStr, 80, rowval);\r\n\trowval += inc;\r\n\t\r\n\tif(PPCond)\r\n\t\tOvlp  = Overlap(L, H, O, C, ConIndex, PvtIndex[0], PvtIndex[1], PvtIndex[2], PvtIndex[3]);\r\n\telse\r\n\t\tOvlp  = Overlap(L, H, O, C, ConIndex, PvtIndex[2], PvtIndex[3], PvtIndex[4], PvtIndex[5]);\r\n\t\t\r\n\tOvstr = "Overlap: " + WriteIf(IsNull(Ovlp) OR (PvtH &lt;= 6.55 AND PrevH &lt;= 6.55), "N/A", NumToStr(ovlp,  1.1) + "%");\r\n\t\r\n\tthecolor = iif((Ovlp &gt; 23.6 AND Ovlp &lt; 61.798) OR StrMatch(Ovstr, "Overlap: N/A"), colorLime, IIf(IsNull(Ovlp), colorDarkYellow, colorRed));\r\n\tGfxSetTextColor(thecolor[BarCount-1]);\r\n\tGfxTextOut(Ovstr, 80, rowval);\r\n\trowval += inc;\r\n\t\r\n\tthecolor = colorDarkYellow;\r\n\tGfxSetTextColor(thecolor[BarCount-1]);\r\n\tGfxTextOut("Base Depth: " + NumToStr(Depth, 1.1) + "%", 80, rowval);\r\n\trowval += inc;\r\n\t\r\n\t/*\r\n\tVolDryUp = WriteIf(VolOK[0], "Volume Dry Up OK", "Volume Dry Up Not OK");\r\n\tthecolor = iif(VolOK[0], colorLime, colorRed);\r\n\tGfxSetTextColor(thecolor[BarCount-1]);\r\n\tGfxTextOut(VolDryUp, 65, rowval);\r\n\trowval += inc;\r\n\t\r\n\tVolAcc   = WriteIf(VolOK[1], "Volume Accumulation OK", "Volume Accumulation Not OK");\r\n\tthecolor = iif(VolOK[1], colorLime, colorRed);\r\n\tGfxSetTextColor(thecolor[BarCount-1]);\r\n\tGfxTextOut(VolAcc, 65, rowval);\r\n\trowval += inc;\r\n\t\r\n\tPDtext = NumToStr(PriceDisp*100, 1.1);\r\n\tPDSlpt = NumToStr(PDSlp*100/LastValue(C), 1.1);\r\n\tthecolor = iif(PriceDisp &lt;= 0.05, colorLime, colorRed);\r\n\tGfxSetTextColor(thecolor[BarCount-1]);\r\n\tGfxTextOut("Price Dispersion: " + PDtext + " %,  slope: " + PDSlpt + " %" , 65, rowval);\r\n\trowval += inc;\r\n\t*/\r\n\t\r\n\r\n}\r\n\r\n\tGfxSelectFont("Calibri", 14, 1000, False, False, 0);\r\n\r\n// dolvol\r\n\trngdolvol = LastValue(BarsSince(IsNull(C)))-1;\r\n\tif(rngdolvol &lt; 0)\r\n\t\trngdolvol = 50;\r\n\tdolvol \t\t= C*MA(V, Min(50, rngdolvol));\r\n\tdolvoltext \t= "DolVol: " + NumToStr(LastValue(dolvol), 1.0) + " $";\r\n\tIPODVOK \t= (BarCount &lt;= 12*21 AND LastValue(dolvol) &gt;= 2.5e7);\r\n\tClassicDVOK = LastValue(dolvol) &gt;= 1e7;\r\n\tPPDVOK\t\t= LastValue(dolvol) &gt;= 2.5e7 AND VldPPBase;\r\n\tthecolor \t= IIf(IPODVOK OR ClassicDVOK OR PPDVOK, colorLime, colorRed);\r\n\tGfxSetTextColor(thecolor[BarCount-1]);\r\n\tGfxTextOut(dolvoltext, 65, rowval);\r\n\trowval += inc;\r\n\t\r\n// float\r\n\tFloat   = GetFnData("SharesFloat");\r\n\tthecolor = iif(Float &lt; 3e7, colorLime, colorDarkYellow);\r\n\tGfxSetTextColor(thecolor[BarCount-1]);\r\n\tGfxTextOut("Float: " + NumToStr(Float/1e6, 1.1) + " Msh", 65, rowval);\r\n\r\n////// end disp\r\n\t\r\n// VCP Graphics\r\n\t// Using GetAsyncKeyState()\r\n\tnMM = 6; //Max no. of MM lines\r\n\t\r\n\tbi = BarIndex();\r\n\tdt = DateTime();\r\n\tt=0;\r\n\tpct="";\r\n\tduration = "";\r\n\ttitel_new = "";\r\n\tMouseBtn = GetCursorMouseButtons();\r\n\tLeftJustClkd = MouseBtn &amp; 8;\r\n\tLeftClkDownRlsd = MouseBtn &amp; 9;\r\n\tMiddleClkd = MouseBtn &amp; 4;\r\n\tchartId = Name() + Interval();\r\n\t\r\n\tx = GetCursorXPosition( 0 );\r\n\ty = GetCursorYPosition( 0 );\r\n\t\r\n\tif( GetAsyncKeyState( 48 ) &lt; 0 OR GetAsyncKeyState( 96 ) &lt; 0 AND MiddleClkd )\r\n\t{\r\n\t\tStaticVarRemove( "x1*" );\r\n\t\tStaticVarRemove( "y1*" );\r\n\t\tStaticVarRemove( "x2*" );\r\n\t\tStaticVarRemove( "y2*" );\r\n\t\tStaticVarRemove( "pct_t*" );\r\n\t}\r\n\t\r\n\tfor( i = 49; i &lt;= 48 + nMM; i++ )\r\n\t{\r\n\t\triMM = i - 48;\t\r\n\t\tDigitPressed = GetAsyncKeyState( i ) &lt; 0 || GetAsyncKeyState( i + 48 ) &lt; 0;\r\n\t\tif( DigitPressed )\r\n\t\t{\r\n\t\t\t// This elegant technique shared by @Milosz\r\n\t\t\tif( LeftJustClkd )\r\n\t\t\t{\r\n\t\t\t\tStaticVarSet( "x1" + chartId + riMM, x, 0 );\r\n\t\t\t\tStaticVarSet( "y1" + chartId + riMM, y, 0 );\r\n\t\t\t\t//StaticVarSet( "y1_start" + chartId + riMM, bi, 0 );\r\n\t\t\t\t\r\n\t\t\t}\t\r\n\t\t\tif( LeftClkDownRlsd )\r\n\t\t\t{\r\n\t\t\t\tStaticVarSet( "x2" + chartId + riMM, x, 0 );\r\n\t\t\t\tStaticVarSet( "y2" + chartId + riMM, y, 0 );\t\t\r\n\t\t\t}\r\n\t\t\tif( MiddleClkd )\r\n\t\t\t{\r\n\t\t\t\tStaticVarRemove( "x1" + chartId + riMM );\r\n\t\t\t\tStaticVarRemove( "y1" + chartId + riMM );\r\n\t\t\t\tStaticVarRemove( "x2" + chartId + riMM );\r\n\t\t\t\tStaticVarRemove( "y2" + chartId + riMM );\r\n\t\t\t\tStaticVarRemove( "pct_t" + chartId + riMM );\r\n\t\t\t}\r\n\t\t\tRequestMouseMoveRefresh();\r\n\t\t}\r\n\t}\r\n\t\r\n\tGfxSetBkMode( 1 );\r\n\tGfxSetCoordsMode( 1 ); // mode = 1 - bar / price mode where X is expressed in bar index and Y is expressed in price.\r\n\t\r\n\tfor( i = 1; i &lt;= nMM; i++ )\r\n\t{\r\n\t\tx1 = Lookup( bi, StaticVarGet( "x1" + chartId + i ) );\r\n\t\ty1 = StaticVarGet( "y1" + chartId + i );\r\n\t\tx2 = Lookup( bi, StaticVarGet( "x2" + chartId + i ) );\r\n\t\ty2 = StaticVarGet( "y2" + chartId + i );\r\n\t\tif( x1 != 0 AND x2 != 0 )\r\n\t\t{\r\n\t\t\tt++;\r\n\t\t\tGfxSelectPen( colorGrey50, 2, 1 );\r\n\t\t\tGfxMoveTo( x1, y1 );\t\tGfxLineTo( x2, y2 ); \t// Diagonal line\r\n\t\t\t\r\n\t\t\tGfxSelectFont( "Courier New", 9.5, 700 );\r\n\t\t\tpct0 = NumToStr( abs(y2/y1-1)*100, 1.0, False );\r\n\t\t\tpct1 = NumToStr( abs(y2/y1-1)*100, 1.1, False );\r\n\t\t\tGfxTextOut( "   T"+NumToStr( i, 1.0 )+": " +pct1 , x1-13 , y1+0.3 );\r\n\t\t\tStaticVarSetText("pct_t" + chartId + i, pct0, false);\r\n\t\t}\r\n\t}\r\n//EOF\r\n</Formula>
			<FilePath>Formulas\\Custom\\Price 13_imported_imported_imported_imported_imported_imported_imported.afl</FilePath>
			<Flags>256</Flags>
			<MoreFlags>1073741835</MoreFlags>
			<Min>42.7551</Min>
			<Max>76.0844</Max>
		</Pane>
		<Pane>
			<ChartID>1035</ChartID>
			<PercentHeight>16.5563</PercentHeight>
			<Formula>_SECTION_BEGIN("Volume");\r\n\r\nPlot( Volume, _DEFAULT_NAME(), IIf( C &gt;= Ref(C,-1), ParamColor("Up Color", colorBlue ), ParamColor("Down Color", colorRed ) ), ParamStyle( "Style", styleHistogram | styleThick, maskHistogram  ) );\r\n\r\n_SECTION_END();\r\n\r\n_SECTION_BEGIN("VolMA");\r\nVolMA = MA(V, 50);\r\n\r\nPlot(VolMA, "Vol 50-day Avg", colorRed, styleThick);\r\n_SECTION_END();\r\n</Formula>
			<FilePath>Formulas\\Custom\\Volume (color) 21.afl</FilePath>
			<Flags>256</Flags>
			<MoreFlags>1342177285</MoreFlags>
			<Min>370985</Min>
			<Max>8.22193e+06</Max>
		</Pane>
		<Pane>
			<ChartID>999</ChartID>
			<PercentHeight>0</PercentHeight>
			<Formula>_SECTION_BEGIN("Individual");\r\n#include @LastBacktestFormula\r\nMaxGraph=0;GraphXSpace=5;\r\nGraphZOrder=1;\r\nPlot( Equity( 0, -2 ), "Equity", -8, styleArea );\r\n\r\nif( ParamToggle("Show Buy-and-Hold?", "No|Yes", 1 ) )\r\n{\r\n /* now buy and hold simulation */\r\n Short=Cover=0;\r\n Buy=Status("firstbarintest");\r\n Sell=Status("lastbarintest");\r\n SetTradeDelays(0,0,0,0); PositionSize = -100;\r\n ApplyStop(0,0,0,0);\r\n ApplyStop(1,0,0,0);\r\n ApplyStop(2,0,0,0);\r\n Plot( Equity( 0, -2 ), "Buy&amp;Hold", -9 );\r\n}\r\n_SECTION_END();\r\n</Formula>
			<FilePath>Formulas\\Drag-drop\\_Equity.afl</FilePath>
			<Flags>256</Flags>
			<MoreFlags>1342177281</MoreFlags>
			<Min>9974.48</Min>
			<Max>10552.7</Max>
		</Pane>
	</Sheet>
	<Includes>
		<File>
			<Path>&lt;TPT_Func_Lib.afl&gt;</Path>
			<Formula>/* TPT Functions Library\r\nThis AFL contains the library of functions for the TPT Pivot Microstructure Software\r\nThis AFL should be included in any AFL using the functionality below\r\n*/\r\n\r\n/*  List of Functions\r\nSwingLow\r\nSwingHigh\r\nSwingIndex\r\nLowestLow\r\nHighestHigh\r\nHeight\r\nOverlap\r\ngetCSBaseParam\r\ngetCSCapBaseParam\r\ngetPPBaseParam\r\nisPausePivot\r\ngetContractionIndex\r\ngetMSPivotParam\r\ngenRS\r\nTrendFilter\r\ngetTurnLA\r\ngetPPPivotParam\r\ncheckVolume\r\n*/\r\n\r\n/* History\r\nDate Created:  2020-12-21\r\nDate Modified: 2021-03-20\r\n\r\nMod-Sums:\r\n----------\r\n\r\n2021-03-20 MAM:\r\n- Issue 71: PausePivot detection fixed for cap style conditions\r\n\r\n2021-03-13 MAM:\r\n- Issue 57: Changed contraction indexing to remove nuisance contraction high when lows are equal\r\n- Issue 54: Removed capability for pause pivots to be not in the last bar. Lowest low cannot return same bar SH/SL if not the last bar\r\n\r\n2021-03-06 MAM:\r\n- Issue 61: Fixed issue with contraction indexing not taking into account the High of Base as a contraction high\r\n- Issue 62: Fixed issue with contraction indexing missing an intermediate yet valid contraction\r\n\r\n2021-02-12 MAM: \r\n- Issue 39: Created checkVolume function \r\n\r\n2021-02-11 MAM:\r\n- TrendFilter is updated to use closing price and not 50 day average for dollar volume\r\n\r\n2021-02-08 MAM:\r\n- TrendFilter Updated dolvol values to 10 mil for non-IPO and 25 mil for IPO stocks\r\n- getMSPivotParam now doesn't consider previous contraction size. Only overlap is considered\r\n\r\n2021-02-06 MAM:\r\n- Updated getMSPivotParam to allow any size of previous contraction\r\n- getPPPivotParam updated to v1.1 of power squeeze rules\r\n  - Added that pivot in getPPPivotParam needs to be in upper 61.8% of flag \r\n  - Added volume as an input provision and pivot high for actual use\r\n- Updated getPPBaseParam for detection of flag and pole to detect power play and allows overshoot\r\n- updated getTurnLA to remove situation where initial parameters are not defined\r\n- removed min price from trendfilter since it is base dependent\r\n- set global min (8 mil) to dollarvolume as a check in trendfilter since there can be valid exceptions. Will flag in chart instead if invalid\r\n- Issue #49: fixed bug in getContractionIndex and getMSPivotParam for single contraction instances\r\n- Added function isPausePivot\r\n- Issue #47: fixed contraction index loop going past available contractions\r\n- Issue #50: Eliminated pivot detection when already broken out for classic and power squeeze\r\n\t- Muted any swing high lower than the last bar's high\r\n- fixed same day low of pivot in getMSPivotParam\r\n\r\n2021-01-31 MAM:\r\n- Overlap function now inputs a swing index, updated as well getMSPivotParam as a user function\r\n- Updated TurnLA to mute positive slope lines\r\n- Fixed Lowest Low to protect against 0-inputs into LLV function\r\n- removed ATR requirement from trendfilter\r\n\r\n2021-01-30 MAM:\r\n- Issue #32 fixed: Height function needs to take in a swingindex as input could be from various indexing functions\r\n  - No longer uses swinghigh function\r\n- Fixed lowestlow function indexing issue per issue #29\r\n\r\n2021-01-29 MAM:\r\n- Fixed pause pivot per issue #25\r\n\r\n2021-01-16 MAM:\r\n- LowestLow and HighestHigh now take a swingindex as an input. These allows custom swingindexes to be input\r\n\t- this impacted all user functions per the SW architecture to calculate their own generic or custom swing index, accordingly\r\n- Completely rewrote the getMSPivotParam to be more reliable and efficient using Russian doll search\r\n- LowestLow and all user functions must use open and close data since lowest low needs to evaluate same day contractions\r\n- getMSPivotParam: updated max previous contraction to 16%\r\n\r\n2021-01-10 MAM:\r\n- Updated getMSPivotParam to comment out 2-bar pivot for now since it is incorrect\r\n- Updated quality of detection of single bar contraction to take into account close vs open price\r\n- added getPPPivotParam to calculate alternate pivots for power squeezes\r\nTrendfilter:\r\n\t- loosened dolvol and ATR limits to catch marginal stock (will show red in the chart if strictly off, though)\r\n\t- fixed ATR calculation so that it is ATR % \r\n\r\n2021-01-08 MAM:\r\n- Updated getPPBaseParam to account for overshoot in the flag high relative to the pole high\r\n- Updated trendfilter so that ROC function used lowest price in the last 12 months, not just the exact price one year ago\r\n- Updated trendfilter to be robust to IPOs and per IPO scanning criteria on discord server\r\n- updated getCSBaseParam to allow 20 day bases for IPOs\r\n- added nth = null handling for LowestLow and HighestHigh\r\n- rewrote TurnLA so that it's no longer erroneous\r\n- updated genRS to improve percentile ranking code (0-99 instead of 0-100)\r\n\r\n2021-01-07 MAM:\r\n- Integrated Turn Line function into library\r\n- Created exception when last bar needs to be the lowest low of the pivot contraction\r\n  - impacts lowest low, swingindex and getMSPivotParam functions\r\n- Updated getMSPivotParam to deal with exceptions\r\n- Updated that close needs to be within fib number vs 4% of the pivot contraction high\r\n\r\n2021-01-06 MAM:\r\n- Updated getCSBaseParam baselen calculation\r\n- Improved speed of calculation of getCSCapBaseParam\r\n- Added TrendFilter function\r\n- Sped up getMSPivotParam by skipping prev con calculations if pvt con is already invalid\r\n\r\n2021-01-05 MAM:\r\n- Added 4% below pivot high rule that was missing\r\n- Rewrote getCSBaseParam using the new four step process from the following link:\r\n\thttps://discord.com/channels/776518652592652339/791719187823067227/791719686180962346\r\n- Fixed getCSCapBaseParam bugs\r\n- Updated getPPBaseParam to output info data, similar to other bases\r\n\r\n2021-01-03 MAM:\r\n- Created genRS function\r\n\r\n2021-01-02 MAM:\r\n- Removed use of getCSBaseParam from getMSPivotParam, no longer needed1\r\n- Update of getCSBaseParam to correct for omitting checking whether the price is above the base already\r\n- Created getCSCapBaseParam function for detecting cap pattern\r\n- fixed getCSBaseParam for possible out of bounds array read\r\n- fixed detection of base LHS in getCSBaseParam\r\n- removed further dependency of getMSPivotParam on getCSBaseParam\r\n- fixed error in condition of squiggle filter\r\n- added derived Power play detection function getPPBaseParam\r\n\r\n2021-01-01 MAM:\r\n- Removed redundant code from getMSPivotParam (no functional effect)\r\n- Fixed error where Lnth2 search gets behind Hnth2, now it gives up and continues the outer while loop\r\n- Derived requirement for quitting after full overlap by previous contraction over pivot now is only\r\n   enforced when the overlap rule is met or the previous contraction is not too large already\r\n- Fixed inequality to be less than or equal to, to prevent skipping the loop entirely\r\n- increased tolerance to 2 pct to include more marginal situations, added tolerance to overlap rules too\r\n- added tolerance to slip through previous contractions that are slightly smaller\r\n- updated SwingHigh to allow the high of the last bar to be equal to the middle bar\r\n- Fixed squiggle filter so it quits once overshoot is ok\r\n- removed volatility check from getCSBaseParam as this can be done anywhere easily\r\n\r\n2020-12-30 MAM:\r\n- Fixed possible negative indexing in getCSBaseParam and getMSPivotParam\r\n- Complete rewrite of previous contraction search while loop\r\n\r\n2020-12-29 MAM:\r\n- getMsPivotParam UpdateL\r\n  - Added additional selectable output for MS pivot param for prices of contractions\r\n  - Added additional selectable output for MS pivot param for prices in their actual location in array\r\n  - Fixed endless loop error in valid pivot search (TryCount counter)\r\n  - Fixed if condition in while loop to increment Lnth2\r\n  - VldPvtCon is now scalar\r\n  - Added a tunable tolerance to find marginal situations\r\n- Updated Height function to take in separate indices for high and low\r\n- Fixed bug in Lowest Low wher it wasn't catching lows that occur at swinghighs\r\n\r\n2020-12-28 MAM:\r\n- Continue work on isMSPivotValid\r\n- renamed isMSPivotValid to getMSPivotParam as it will return various params\r\n- Updated getCSBaseParam to output scalars for loop compatibility\r\n\r\n2020-12-24 MAM:\r\nAdded:\r\n - getCSBaseParam completed\r\n - isMSPivotValid started\r\n - updated overlap to take in four integers for more flexibility\r\n - Fixed LowestLow again due to similar bug, yesterday's fix didn't work\r\n\r\n2020-12-23 MAM:\r\nModified:\r\n - Renamed function PriceHeight to Height and output to HeightPct to be consistent\r\n - Overlap function completed\r\n - Fixed bug in LowestLow function where wrong low would be selected\r\n\r\n2020-12-22 MAM:\r\nModified:\r\n - SwingLow completed\r\n - SwingHigh completed\r\n - Height -&gt; PriceHeight change in name not to conflict with output name\r\n - Overlap\r\n\r\nAdded\r\n - LowestLow completed\r\n - HighestHigh completed\r\n - SwingIndex completed\r\n\r\n2020-12-21 MAM: Following functions added:\r\n - SwingLow completed\r\n - SwingHigh completed\r\n - Height\r\n - Overlap\r\n*/\r\n\r\n//------------ Function Code ------------//\r\n\r\n/* SwingLow Function\r\n\r\n\tPurpose:\r\n\tUsed to detect low swings in price. Helps with contraction detection\r\n\r\n\tReferences:\r\n\t1._CLASSIC_SQUEEZE_PIVOTS_FORMING_ABOVE_THE_TURN_-_Di_Mauro_Perfect_Pivot_thePrivateTrader.com_Pivot.pdf\r\n\r\n\tInput: \tLow price array of current ticker\r\n\tOutput: Binary array which flags bottom of each Swing High with TRUE, otherwise False\r\n*/\r\nfunction SwingLow( LL )\r\n{\r\n    // Tunable Parameters\r\n    HightoLowThresh = 0;\t// Positive-only percent value. Force a gap between first low to second low.\r\n    // Zero assumes anything lower than works\r\n    LowtoHighThresh = 0;\t// Positive-only percent value. Force a gap between second low to third low.\r\n    // Zero assumes anything greater than works\r\n\r\n    // Low bar ref points\r\n    FirstBar \t= Ref( LL, -2 );\r\n    SecondBar\t= Ref( LL, -1 );\r\n    ThirdBar\t= LL;\r\n\r\n    // Threshold gain calculations. Converts percentage thresholds to gain value\r\n    FTSGain = 1 + HightoLowThresh;\t// First To Second bar gain\r\n    STTGain = 1 + LowtoHighThresh;  // Second To Third bar gain\r\n\r\n    // Calculates detection of swing low as referenced in the last bar\r\n    SwingLowTrue = FirstBar &gt; SecondBar * FTSGain AND ThirdBar &gt; SecondBar * STTGain;\r\n\r\n    // Since swings lows are usually pointed out at the trough, shift detection to match this visualization\r\n    // Even if ref uses positive index, it's still causal as the intent is to only shift the detection to\r\n    // the right place\r\n    SwingLowInd = Ref( SwingLowTrue, 1 );\r\n\r\n    // Ensure last bar is false since it cannot possibly be a swing\r\n    SwingLowInd[BarCount - 1] = False;\r\n\r\n    // Return Statement\r\n    return SwingLowInd;\r\n}\r\n\r\n/* SwingHigh Function\r\n\r\n\tPurpose: Used to detect high swings in price. Helps with contraction detection\r\n\r\n\tReferences:\r\n\t1._CLASSIC_SQUEEZE_PIVOTS_FORMING_ABOVE_THE_TURN_-_Di_Mauro_Perfect_Pivot_thePrivateTrader.com_Pivot.pdf\r\n\r\n\tInput: High price array of current ticker\r\n\tOutput: Binary array which flags bottom of each Swing High with TRUE, otherwise False\r\n*/\r\nfunction SwingHigh( HH )\r\n{\r\n    // Tunable Parameters\r\n    LowtoHighThresh = 0;\t// Positive-only percent value. Force a gap between first high to second high.\r\n    // Zero assumes anything greater than works\r\n    HightoLowThresh = 0;\t// Positive-only percent value. Force a gap between second high to third high.\r\n    // Zero assumes anything lower than works\r\n\r\n    // Low bar ref points\r\n    FirstBar \t= Ref( HH, -2 );\r\n    SecondBar\t= Ref( HH, -1 );\r\n    ThirdBar\t= HH;\r\n\r\n    // Threshold gain calculations. Converts percentage thresholds to gain value\r\n    FTSGain = 1 + LowtoHighThresh;\t// First To Second bar gain\r\n    STTGain = 1 + HightoLowThresh;  // Second To Third bar gain\r\n\r\n    // Calculates detection of swing low as referenced in the last bar\r\n    SwingHighTrue = FirstBar * FTSGain &lt; SecondBar AND ThirdBar * STTGain &lt;= SecondBar;\r\n\r\n    // Since swings lows are usually pointed out at the trough, shift detection to match this visualization\r\n    // Even if ref uses positive index, it's still causal as the intent is to only shift the detection to\r\n    // the right place\r\n    SwingHighInd = Ref( SwingHighTrue, 1 );\r\n\r\n    // Ensure last bar is false since it cannot possibly be a swing\r\n    SwingHighInd[BarCount - 1] = False;\r\n\r\n    // Return Statement\r\n    return SwingHighInd;\r\n\r\n}\r\n\r\n/* SwingIndex Function\r\n\r\n\tPurpose:\r\n\tReturn the bars since the nth swing (high or low)\r\n\r\n\tReferences:\r\n\t1._CLASSIC_SQUEEZE_PIVOTS_FORMING_ABOVE_THE_TURN_-_Di_Mauro_Perfect_Pivot_thePrivateTrader.com_Pivot.pdf\r\n\r\n\tInput: \tSwingIndex, binary array which can be swinghighind or swinglowind or other similar index\r\n\t\t\tInteger for which contraction to check. 1 is most recent, 2 is 2nd most recent...\r\n\tOutput: Scalar Bars since N occurrence of a swing (high or low)\r\n*/\r\nfunction SwingIndex( SwingInd, nth )\r\n{\r\n    // Reference back nth swings, counting the bars while doing so\r\n\r\n    // Set the reference high reference to initial swinghigh index and low price array\r\n    IndRef = SwingInd;\r\n    count  = LastValue( BarsSince( IndRef ) );\r\n\r\n    // Loop to set arrays to nth swing, skip if nth = 0 or 1\r\n    for( i = 1; i &lt; nth; i++ )\r\n    {\r\n        // retrieve the number of bars since the last swing\r\n        refbar\t= LastValue( BarsSince( IndRef ) );\r\n        // shift the Swing reference accordingly\r\n        IndRef\t= Ref( IndRef,  -refBar - 1 );\r\n        // add the number of bars to the preceding swing\r\n        count  += LastValue( BarsSince( IndRef ) ) + 1;\r\n    }\r\n\r\n\t// special handling for low being last bar low\r\n\tif (nth == 0)\r\n\t\tBarsSinceSwing = 0;\r\n\telse\r\n\t\tBarsSinceSwing = count;\r\n\r\n    // return the accumulation of bars pointing to where the nth swing is\r\n    return BarsSinceSwing;\r\n}\r\n\r\n/* LowestLow Function\r\n\r\n\tPurpose: DetectLowest Low between SwingHighs\r\n\r\n\tReferences:\r\n\t1._CLASSIC_SQUEEZE_PIVOTS_FORMING_ABOVE_THE_TURN_-_Di_Mauro_Perfect_Pivot_thePrivateTrader.com_Pivot.pdf\r\n\r\n\tInput:\tLow price arracy, high price array, open price array, close price array\r\n\t\t\tSwing Index binary array\r\n\t\t\tInteger to return the lowest low of the nth swing high, 1 being the most recent\r\n\tOutput: Scalar Lowest Price\r\n*/\r\nfunction LowestLow( LL, HH, OO, CC, SwingIndex, nth )\r\n{\r\n    // Move reference so that we capture the nth lowest low of the nth swing high\r\n    // if nth = 1, skip the for loop since i is never less than nth\r\n\r\n    // Set the reference high reference to initial swinghigh index and low price array\r\n    SHRef\t= SwingIndex;  // now an input\r\n    LowRef \t= LL;\r\n\r\n    // Loop to set arrays to nth swing high to lowest low, skip if 0 or 1\r\n    \r\n    for (i = 1; i &lt; nth; i++)\r\n    {\r\n        // retrieve the number of bars since the last swinghigh\r\n        refbar\t= LastValue( BarsSince( SHRef ) );\r\n        // shift the Swinghigh reference accordingly\r\n        SHRef\t= Ref( SHRef,  -refBar );\r\n        // shift the low price reference accordingly\r\n        LowRef\t= Ref( LowRef, -refBar );\r\n        \r\n        // shift remaining price arrays\r\n        HH\t= Ref( HH, -refBar );\r\n        OO\t= Ref( OO, -refBar );\r\n        CC\t= Ref( CC, -refBar );\r\n\r\n        // Mute the nth+1 SwingHigh or the loop will get stuck\r\n        // the reason to mute instead of reference another bar back is that this last bar could be the low\r\n        SHRef[BarCount - 1] = False;\r\n    }\r\n\r\n    \r\n    // special handling if pivot low is the last bar\r\n    if (nth == 0)\r\n    {\r\n\t\tLLPrice = LastValue(LL);\r\n    }\r\n    else\r\n    {\r\n\t\t// Bars since last swing high on the reference bars\r\n\t\tSHBars  = LastValue( BarsSince( SHRef ) );\r\n\t\t// Lowest price since SHBars\r\n\t\tLLPrice = LastValue( LLV( LowRef, SHBars + 1) );\r\n\r\n\t\t// Handling for same day swing high and low\r\n\t\t// Barssince the lowest price\r\n\t\tLLBars  = LastValue( BarsSince( LowRef == LLPrice ) );\r\n\t\t\r\n\t\t// if same day swing high or swing low and not the last bar\r\n\t\tif (SHBars == LLBars AND LLBars &gt; 0)\r\n\t\t{\r\n\t\t\t// reduce period to one bar ahead\r\n\t\t\tSHBars--;\r\n\t\t\t// set actual new low price\r\n\t\t\tLLPrice = LastValue( LLV( LowRef, Max(1, SHBars) ) );\r\n\t\t}\r\n    }\r\n    \r\n    if (IsNull(nth)) \r\n\t\tLowestLowPrice = Null;\r\n\telse\r\n\t\tLowestLowPrice = LLPrice;\r\n\r\n    return LowestLowPrice;\r\n}\r\n\r\n/* HighestHigh Function\r\n\r\n\tPurpose: Return the high price of the nth swinghigh\r\n\r\n\tReferences:\r\n\t1._CLASSIC_SQUEEZE_PIVOTS_FORMING_ABOVE_THE_TURN_-_Di_Mauro_Perfect_Pivot_thePrivateTrader.com_Pivot.pdf\r\n\r\n\tInput:\thigh price array\r\n\t\t\tSwing Index binary array\r\n\t\t\tInteger to return the lowest low of the nth swing high, 1 being the most recent\r\n\tOutput: Scalar highest price\r\n*/\r\nfunction HighestHigh( HH, SwingIndex, nth )\r\n{\r\n    // Move reference so that we capture the nth highest high of the nth swing high\r\n    // if nth = 1, skip the for loop since i is never less than nth\r\n\r\n    // Set the reference high reference to initial swinghigh index and low price array\r\n    SHRef\t= SwingIndex; // now an input\r\n    HighRef\t= HH;\r\n\r\n    // Loop to set arrays to nth swing high to lowest low\r\n    for( i = 1; i &lt; nth; i++ )\r\n    {\r\n        // retrieve the number of bars since the last swinghigh\r\n        refbar\t= LastValue( BarsSince( SHRef ) );\r\n        // shift the Swinghigh reference accordingly\r\n        SHRef\t= Ref( SHRef,   -refBar - 1 );\r\n        // shift the low price reference accordingly\r\n        HighRef\t= Ref( HighRef, -refBar - 1 );\r\n    }\r\n\r\n    // Mute the nth+1 SwingHigh\r\n    SHRef[BarCount - 1] = False;\r\n\r\n    // Determine the period since the last swinghigh\r\n    HighestHighPeriod = IIf(nth == 0, 0, LastValue( BarsSince( SHRef ) ));\r\n\r\n    // Get the lowest price within the last swing high\r\n    HighestHighPrice  = HighRef[BarCount - HighestHighPeriod - 1];\r\n    \r\n    if (IsNull(nth)) \r\n\t\tHighestHighPrice = Null;\r\n\r\n    return HighestHighPrice;\r\n}\r\n\r\n/* Height Function\r\n\r\n\tPurpose:\r\n\tUsed to measure height from a high to low, which can be a candidate contraction.\r\n\r\n\tReferences:\r\n\t1._CLASSIC_SQUEEZE_PIVOTS_FORMING_ABOVE_THE_TURN_-_Di_Mauro_Perfect_Pivot_thePrivateTrader.com_Pivot.pdf\r\n\r\n\tInput: \tHigh Price, Low Price arrays, open price array, close price array\r\n\t\t\tSwingIndex, is usually the output of SwingHigh SwingLow ConIndex\r\n\t\t\tHnth, Lnth Integers for which contraction to check. 1 is most recent, 2 is 2nd most recent...\r\n\tOutput: Percent array giving percent change between low and previous high\r\n*/\r\nfunction Height( LL, HH, OO, CC, SH, Lnth, Hnth )\r\n{\r\n    // Calculate peak and trough from high to low\r\n    LowPrice  = LowestLow( LL, HH, OO, CC, SH, Lnth );\r\n    HighPrice = HighestHigh(   HH, SH, Hnth );\r\n\r\n\r\n    // Determine height in percent\r\n    HeightPct = -( LowPrice / HighPrice - 1 ) * 100;\r\n\r\n    return HeightPct;\r\n}\r\n\r\n/* Overlap Function\r\n\r\n\tPurpose:\r\n\tDetermine the amount of overlap the current contraction has vs the previous\r\n\r\n\tReferences:\r\n\t1._CLASSIC_SQUEEZE_PIVOTS_FORMING_ABOVE_THE_TURN_-_Di_Mauro_Perfect_Pivot_thePrivateTrader.com_Pivot.pdf\r\n\r\n\tInput:\tHigh Price, Low Price arrays, open price array, close price array\r\n\t\t\tLow and High binary indices. True if high or low is to be considered\r\n\t\t\tintegers Lnth1, Lnth2, Hnth1, Hnth2, which indicates which contractions to compare,\r\n\t\t\twhere 1 is the most recent, 2 is the 2nd most recent, etc.\r\n\tOutput: Overlap as a percentage of coverage of nth1 contraction compared to nth2\r\n*/\r\nfunction Overlap( LL, HH, OO, CC, SH, Lnth1, Hnth1, Lnth2, Hnth2 )\r\n{\t\r\n    // Get the high price of the nth1 contraction\r\n    HighPrice1st = HighestHigh( HH, SH, Hnth1 );\r\n\r\n    // Get the low price of the nth1 contraction\r\n    LowPrice1st  = LowestLow( LL, HH, OO, CC, SH, Lnth1 );\r\n\r\n    // Get the high price of the nth2 contraction\r\n    HighPrice2nd = HighestHigh( HH, SH, Hnth2 );\r\n\r\n    // Get the low price of the 2nd nth2 contraction\r\n    LowPrice2nd\t = LowestLow( LL, HH, OO, CC, SH, Lnth2 );\r\n\r\n    // encode the condition for over four situations:\r\n    // Cond 1 - nth1 low  &lt;  nth2 low\t= 1\r\n    // Cond 2 - nth1 low  &gt;= nth2 low\t= 2\r\n    // Cond 3 - nth1 high &lt;  nth2 high\t= 4\r\n    // Cond 4 - nth1 high &gt;= nth2 high\t= 8\r\n    // Cond 5 - nth1 low  &gt;  nth2 high  = 16\r\n    // Cond 6 - nth1 high &lt;  nth2 low   = 16\r\n\r\n    // Calculate the encoding\r\n    CondEncode = IIf( LowPrice1st &lt; LowPrice2nd, 1, 2 ) + IIf( HighPrice1st &lt; HighPrice2nd, 4, 8 );\r\n    // Override previous statement if no overlap at all\r\n    CondEncode = IIf( LowPrice1st &gt; HighPrice2nd OR HighPrice1st &lt; LowPrice2nd, 16, CondEncode );\r\n\r\n    // Calculate the overlap in percent given the encoding\r\n    switch( CondEncode )\r\n    {\r\n            // nth1 is within nth2 completely\r\n            // Encoding: Cond2 and Cond3 = 2 + 4 = 6\r\n        case 6:\r\n            OverlapPct = ( HighPrice1st - LowPrice1st ) / ( HighPrice2nd - LowPrice2nd ) * 100;\r\n            break;\r\n\r\n            // nth1 has lower low and lower high than nth2\r\n            // Encoding: Cond1 and Cond3 = 1 + 4 = 5\r\n            // Therefore the overlap is considered starting from the nth2 contraction low\r\n        case 5:\r\n            OverlapPct = ( HighPrice1st - LowPrice2nd ) / ( HighPrice2nd - LowPrice2nd ) * 100;\r\n            break;\r\n\r\n            // nth1 has a higher low and higher high than nth2\r\n            // Encoding: Cond2 and Cond4 = 2 + 8 = 10\r\n            // Therefore the overlap ends at the hight price of the nth2 contraction\r\n        case 10:\r\n            OverlapPct = ( HighPrice2nd - LowPrice1st ) / ( HighPrice2nd - LowPrice2nd ) * 100;\r\n            break;\r\n\r\n            // nth1 has a lower low and a higher than nth2\r\n            // Encoding: Cond1 and Cond4 = 1 + 8 = 9\r\n            // Therefore nth1 completely enveloped nth2 and overlap is always 100%\r\n        case 9:\r\n            OverlapPct = 100;\r\n            break;\r\n\r\n            // nth1 is completely above or below nth2\r\n            // Encoding: Cond5 or Cond6 = 16 or 32\r\n            // Always 0%\r\n        case 16:\r\n            OverlapPct = 0;\r\n            break;\r\n\r\n            // error case\r\n        default:\r\n            OverLapPct = -1;\r\n            break;\r\n    }\r\n\r\n    return OverlapPct;\r\n}\r\n\r\n/* getCSBaseParam Function\r\n\r\n\tPurpose:\r\n\tDetermine if the classic base is valid\r\n\t- Greater than 30 days within 6 months, less than 35% deep\r\n\t- ATR(30)/Price &lt; 6.5% as a volatility check\r\n\r\n\tCan also return other parameters of the base based on the "Info" input selection\r\n\r\n\tReferences:\r\n\t1._CLASSIC_SQUEEZE_PIVOTS_FORMING_ABOVE_THE_TURN_-_Di_Mauro_Perfect_Pivot_thePrivateTrader.com_Pivot.pdf\r\n\tCSBase Four Step Process.png\r\n\r\n\tInput:\tHigh Price, Low Price arrays, open price array, close price array\r\n\t\t\tstring where depending on the input, gives a different output. See output section\r\n\r\n\tOutput:\r\n\t\t\tInfo = "Validity" \t-&gt; Scalar Boolean indicating true or false\r\n\t\t\tInfo = "LHSPrice" \t-&gt; Gives high price of left side of CS base\r\n\t\t\tInfo = "LHSBars"  \t-&gt; Gives bars since the LHS high of the CS base occurred\r\n\t\t\tInfo = "LowPrice" \t-&gt; Gives low price of CS base\r\n*/\r\nfunction getCSBaseParam( LL, HH, OO, CC, Info )\r\n{\r\n    // Assumption is average of 21 trading days per month or 126 days per 6 months.\r\n    // Round up to 130 days\r\n    // DERIVED REQT: Max base length is six months\r\n    SixMths = Min( 130, BarCount - 1 );\r\n\r\n    // Set min requirement parameters\r\n    BaseLenMin \t\t= 30;\t// days\r\n    BaseLenMin = IIf(BarCount - 1 == SixMths, 20, 30);\r\n    \r\n    BaseDepthMax \t= 35;   // percent from base low to base high\r\n    \r\n    SH = SwingHigh(HH);  // generic swinghigh index\r\n\r\n\t// Follow the four-step process for determining a classic squeeze base\r\n\t\r\n\t//// 1. Find the base highest high\r\n\t// initialize loop params\r\n\tBaseHH\t= 0;\r\n\ti \t\t= 1; // skip first swing since it obviously isn't the LHS of the base\r\n\tBHSince = 0;\r\n\tdo\r\n\t{\r\n\t\t// increment to the next highest high\r\n\t\ti++;\r\n\t\t\r\n\t\t// get highest high\r\n\t\tBaseHHCand  = HighestHigh(HH, SH, i);\r\n\t\t\r\n\t\t// get 'barssince' value of the candidate base high;\r\n\t\tBHSinceCand = SwingIndex(SH, i);\r\n\t\t\r\n\t\t// set new base high if it beats the old one\r\n\t\tif (BaseHHCand &gt; BaseHH)\r\n\t\t{\r\n\t\t\t// Set to new high candidate\r\n\t\t\tBaseHH \t= BaseHHCand;\r\n\t\t\t\r\n\t\t\t// Set barssince value of new base high\r\n\t\t\tBHSince = BHSinceCand;\r\n\t\t\t\r\n\t\t\t// set Hnth to new highest high index \r\n\t\t\tHnth\t= i;\r\n\t\t}\r\n\t\t\r\n\t}\t// loop while under the six mth limit\r\n\twhile (BHSinceCand &lt;= SixMths);\r\n\t\r\n\t//// 2. Find the lowest low after the highest high\r\n\t// initialize loop params\r\n\tBaseLL\t= 1e6;\t// artificially high number\r\n\ti \t\t= 0;\r\n\tBLSince = 0;\r\n\tdo\r\n\t{\r\n\t\t// increment to the next lowest low;\r\n\t\ti++;\r\n\t\t\r\n\t\t// get the lowest low\r\n\t\tBaseLLCand \t= LowestLow(LL, HH, OO, CC, SH, i);\r\n\t\t\r\n\t\t// get 'barssince' value of the candidate base low;\r\n\t\tBLSinceCand = SwingIndex(SH, i);\r\n\t\t\r\n\t\t// set new base low if it beats the old one\r\n\t\tif (BaseLLCand &lt; BaseLL)\r\n\t\t{\r\n\t\t\t// Set to new high candidate\r\n\t\t\tBaseLL \t= BaseLLCand;\r\n\t\t\t\r\n\t\t\t// Set barssince value of new base high\r\n\t\t\tBLSince = BLSinceCand;\r\n\t\t\t\r\n\t\t\t// set Hnth to new highest high index \r\n\t\t\tLnth\t= i;\r\n\t\t}\r\n\t\t\r\n\t} // loop while ahead of the base high\r\n\twhile (BLSinceCand &lt; BHSince);\r\n\t\r\n\t//// 3. Draw a horizontal box to teh left and right with a depth between the points in 1 &amp; 2\r\n\t// get binary array where the price high is greater than the base low and lower than the base high\r\n\tinRect = HH &gt;= BaseLL AND HH &lt;= BaseHH AND BarIndex() &gt; BarCount - SixMths;\r\n\t\t\r\n\t//// 4. Count how many days are within the box = BASE width\r\n\t// Get the number of bars between beginning and end of base\r\n\tBaseLen \t= LastValue(BarsSince(inRect == 0));\r\n\t\t\r\n\t//// Determine base validity\t\r\n\t// check if it meets the length requirements\r\n\t\r\n\t/// Disregard same day Base high/lows\r\n\t// overall length validity\r\n\tBaseLenOK \t= BaseLen &gt;= BaseLenMin;\r\n\t\r\n\t/// Check if the depth meets the requirements\r\n\tBaseDepth   = (1 - BaseLL/BaseHH)*100;\r\n\r\n\t// rule out this is not in fact just a deeper base\r\n\tBaseAbsLow = LastValue(LLV(LL, BaseLen));\r\n\t\r\n\t// overall depth validity\t\r\n\tBaseDepthOK = BaseDepth &lt; BaseDepthMax;\r\n\t\r\n\t// Check if broken out\r\n\tBrokenOut \t= LastValue(HH) &gt; BaseHH;\r\n\t\r\n\t// Overall Validity\r\n\tValidBase \t= BaseLenOK AND BaseDepthOK AND NOT BrokenOut;\r\n \r\n    // Return value based on Info input\r\n    switch( Info )\r\n    {\r\n        case "Validity":\r\n            output = ValidBase;\r\n            break;\r\n\r\n        case "LHSPrice":\r\n            output = BaseHH;\r\n            break;\r\n\r\n        case "LHSBars":\r\n            output = BaseLen;\r\n            break;\r\n\r\n        case "LowPrice":\r\n            output = BaseLL;\r\n            break;\r\n    }\r\n\r\n    return output;\r\n}\r\n\r\n/* getCSCapBaseParam Function\r\n\r\n\tPurpose:\r\n\tDetermine if the Cap base is valid\r\n\t- Similar to determine getCSBaseParam, but allows a cap situation\r\n\r\n\tCan also return other parameters of the base based on the "Info" input selection\r\n\r\n\tReferences:\r\n\t1._CLASSIC_SQUEEZE_PIVOTS_FORMING_ABOVE_THE_TURN_-_Di_Mauro_Perfect_Pivot_thePrivateTrader.com_Pivot.pdf\r\n\r\n\tInput:\tHigh Price, Low Price arrays, open, close arrays\r\n\t\t\tstring where depending on the input, gives a different output. See output section\r\n\r\n\tOutput:\r\n\t\t\tInfo = "Validity" -&gt; Scalar Boolean indicating true or false\r\n\t\t\tInfo = "LHSPrice" -&gt; Gives high price of left side of Cap base\r\n\t\t\tInfo = "LHSBars"  -&gt; Gives bars since the LHS high of the Cap base occurred\r\n\t\t\tInfo = "LowPrice" -&gt; Gives low price of Cap base\r\n*/\r\nfunction getCSCapBaseParam( LL, HH, OO, CC, Info )\r\n{\r\n    //// Tunable parameters\r\n    // Cap time and depth limits\r\n    CapHeightLimPct\t\t= 15;\r\n    CapTimeLimMin\t\t= 10;\r\n    CapTimeLimMax\t\t= 20;\r\n    \r\n    // Max Baselen (see getCSBaseParam)\r\n    SixMths = 130;\r\n\r\n    //// Search for RHS of CS Base  \r\n    // rewinding of price arrays for calls to getCSBaseParam\r\n    LLRef = LL;\r\n    HHRef = HH;\r\n    CCRef = CC;\r\n    // init flag if base was found\r\n    CSBaseFound = False;\r\n    \r\n    // start search from cap high\r\n    i = LastValue(HHVBars(HH, CapTimeLimMax));\r\n\r\n    // start while loop\r\n    // NB if it exits right away, this is actually not a cap pattern but a normal CS Base\r\n    while( NOT CSBaseFound AND i &lt;= CapTimeLimMax )\r\n    {\r\n        //rewind by a day\r\n        LLRef = Ref( LL, -i );\r\n        HHRef = Ref( HH, -i );\r\n        OORef = Ref( OO, -i );\r\n        CCRef = Ref( CC, -i );\r\n\r\n        // check if a CS base is found\r\n        CSBaseFound = getCSBaseParam( LLRef, HHRef, OORef, CCRef, "Validity" );\r\n\r\n        i++;\r\n    } // end while\r\n\r\n    // determine cap validity\r\n    // Check cap length is within limits\r\n    CapLengthOK\t = i &gt;= CapTimeLimMin AND i &lt;= CapTimeLimMax;\r\n    \r\n    // derive the cap high\r\n    CapHigh\t\t = HHV( H, i );\r\n    \r\n    // determine estimate for base high without calling getCSBaseParam, which will slow things down\r\n    CapLow\t\t = HHV(Ref(H, -i), SixMths);    \r\n    \r\n    // determine cap height validity\r\n    CapHeightOK  = ( CapHigh / CapLow - 1 ) * 100 &lt; CapHeightLimPct;\r\n\r\n    // Determine overall cap validity\r\n    ValidBase = LastValue( CSBaseFound AND CapLengthOK AND CapHeightOK );\r\n\r\n\toutput = 0;\r\n    switch( Info )\r\n    {\r\n        case "Validity":\r\n            output = ValidBase;\r\n            break;\r\n\r\n        case "Values":\r\n\t\t\t// get CS Base LHS Price\r\n\t\t\tLHSPrice  \t= getCSBaseParam( LLRef, HHRef, OORef, CCRef, "LHSPrice" );\r\n            output[0] \t\t= LHSPrice;\r\n       \r\n\t\t\t// get CS base LHSBars\r\n\t\t    LHSBars  \t= getCSBaseParam( LLRef, HHRef, OORef, CCRef, "LHSBars" );\r\n\t\t\t// add length of cap to base length for length of entire pattern\r\n\t\t\tLHSBars     = LHSBars + i - 1;\r\n            output[1] = LHSBars;\r\n\r\n\t\t    //get CS Base Low Price\r\n\t\t    LowPrice \t= getCSBaseParam( LLRef, HHRef, OORef, CCRef, "LowPrice" );\r\n            output[2] = LowPrice;\r\n            \r\n            break;\r\n    }\r\n\r\n    return output;\r\n}\r\n\r\n/* getPPBaseParam Function\r\n\r\n\tPurpose:\r\n\tDetermine if the power play base is valid\r\n\r\n\tCan also return other parameters of the base based on the "Info" input selection\r\n\r\n\tReferences:\r\n\tDERIVED FOR NOW\r\n\r\n\tInput:\tHigh Price, Low Price arrays.\r\n\t\t\tstring where depending on the input, gives a different output. See output section\r\n\r\n\tOutput:\r\n\t\t\tInfo = "Validity" -&gt; Scalar Boolean indicating true or false\r\n\t\t\tInfo = "PoleHigh" -&gt; Gives the pole high price\r\n\t\t\tInfo = "PHBar"    -&gt; Gives bars since pole high\r\n\t\t\tInfo = "FlagLow"  -&gt; Gives low price of flag\r\n\t\t\tInfo = "PoleLow"  -&gt; Gives low price of pole\r\n\t\t\tInfo = "PoleLen"  -&gt; gives pole length in bars\r\n*/\r\nfunction getPPBaseParam( LL, HH, Info )\r\n{\r\n    // Tunable Parameters\r\n    BaseLenMax \t\t\t= LLVBars(LL, 130);\r\n\r\n    PoleLowLenMax\t\t=  8 * 5;\t// 8 weeks\r\n    PoleHeightPctMin\t=    95;\t// 100% or more pole height\r\n\r\n    FlagDepthPctMax\t\t=  \t  25;\t// Flag depth is 25%\r\n    //FlagLenMax\t\t\t=\t  50;\t\r\n    FlagLenMin\t\t\t= \t   7;   // Flag length min is 7\r\n    \r\n    FlagOverShootMax\t=      5;\t// allow a flag overshoot of the pole of 5%\r\n\r\n\t// find PHBar and PoleHigh, keeping overshoot in mind\r\n\r\n\t//11 set params for loop\r\n\trefBars \t= 0;\r\n\tHHcheck \t= HH;\r\n\tLLcheck \t= LL;\r\n\tPHBarCount \t= 0;\r\n\tloopmax\t\t= 0;\r\n\tdo\r\n\t{\r\n\t\t// get candidate power play characteristics\r\n\t\tPoleHigh\t\t= HHV(HHcheck, BaseLenMax);\r\n\t\tPHBar\t\t\t= HHVBars( HHcheck, BaseLenMax ) +1;\r\n\t\tPoleLow\t\t\t= Ref( LLV(     LLcheck, PoleLowLenMax ), -PHBar );\r\n\t\tPoleLen\t\t\t= Ref( LLVBars( LLcheck, PoleLowLenMax ), -PHBar ) + 1;    \r\n\t\tPoleHeightPct\t= ( PoleHigh / PoleLow - 1 ) * 100;\r\n\t\t\r\n\t\t// if criteria not met, rewind by PHBars to see if there is another suitable high\r\n\t\tPPValidCand = LastValue(PoleLen &lt;= PoleLowLenMax AND PoleHeightPct &gt;= PoleHeightPctMin AND PHBar + PHBarCount &gt;= FlagLenMin);\r\n\t\tif (NOT PPValidCand)\r\n\t\t{\r\n\t\t\tHHcheck = Ref(HHcheck, -LastValue(PHBar));\r\n\t\t\tLLcheck = Ref(LLcheck, -LastValue(PHBar));\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n\t\tPHBarCount += PHBar;\r\n\t\tloopmax++;\r\n\t}\r\n\twhile (NOT PPValidCand AND loopmax &lt; 5);\r\n\t\r\n\t// sum PHBar to get total length1\r\n\tPHBar = PHBarCount;\r\n\t\r\n\tFlagLow \t\t= LLV( LL, PHBar );\r\n\tFlagDepthPct \t= ( 1 - FlagLow / PoleHigh ) * 100;\r\n\t\r\n\tFlagOvershoot\t= (HHV(HH, PHBar)/PoleHigh - 1) * 100;\r\n\r\n    // Detect HTF if Pole is &gt; 100% and flag is at least 5 bars long and flag % change is &lt; 25%\r\n    PPValid = PoleHeightPct &gt;= PoleHeightPctMin AND FlagDepthPct &lt;= FlagDepthPctMax AND PHBar &gt;= FlagLenMin AND FlagOvershoot &lt; FlagOverShootMax;\r\n\r\n    // return output based on Info request\r\n    switch( Info )\r\n    {\r\n        case "Validity":\r\n            output = LastValue(PPValid);\r\n            break;\r\n\r\n        case "PoleHigh":\r\n            output = LastValue(PoleHigh);\r\n            break;\r\n\r\n        case "PHBar":\r\n            output = LastValue(PHBar);\r\n            break;\r\n\r\n        case "FlagLow":\r\n            output = LastValue(FlagLow);\r\n            break;\r\n            \r\n        case "PoleLow":\r\n\t\t\toutput = LastValue(PoleLow);\r\n\t\t\tbreak;\r\n\t\t\t\r\n\t\tcase "PoleLen":\r\n\t\t\toutput = LastValue(PoleLen);\r\n\t\t\tbreak;\r\n    }\r\n\r\n    return output;\r\n}\r\n\r\nfunction isPausePivot(LL, HH, OO, CC, SwingIndex)\r\n{\r\n    PivotHighPct\t\t= 61.798;\t\t\t\t// Pivot High Pct\r\n    \r\n\t// pause pivot detection\r\n\tPausePCond1 = LastValue(HH &gt; Ref(HH, -1));\t// last high &gt; yesterday high\r\n\tPausePCond2 = LastValue(CC &lt; OO);\t\t\t// red candle\r\n\t// check location of pause pivot relative to potential previous contraction\r\n\t// get low of potential pause pivot low\r\n\t// get low of potential pause pivot previous contraction low\r\n\tPP_PvtConLow  \t= LastValue(  LL);\r\n\tPP_PrevConLow \t= LowestLow(  LL, HH, OO, CC, SwingIndex, 1 );\r\n\tPP_PrevConHigh\t= HighestHigh(    HH, \t\t  SwingIndex, 1 );\r\n\t\r\n\t// Upper third rule\r\n\tPausePCond3\t\t= (PP_PvtConLow - PP_PrevConLow)/(PP_PrevConHigh - PP_PrevConLow)*100 &gt; (100 - PivotHighPct) OR LastValue(Sum(SwingIndex, BarCount-1)) &lt; 2;\r\n\t\r\n\t// check all conditions together\r\n\tPPCond \t\t\t= PausePCond1 AND PausePCond2 AND PausePCond3;\r\n\t\r\n\treturn PPCond;\r\n}\r\n\r\n/* getContractionIndex Function\r\n\r\n\tPurpose:\r\n\tReturns a swingindex that is filtered of nuisance swing highs so that it represents actual contractions\r\n\r\n\tReferences:\r\n\t1._CLASSIC_SQUEEZE_PIVOTS_FORMING_ABOVE_THE_TURN_-_Di_Mauro_Perfect_Pivot_thePrivateTrader.com_Pivot.pdf\r\n\r\n\tInput:\tHigh Price Array, Low Price Array, Open Price Array, Close Price Array\r\n\r\n\tOutput: SwingIndex (boolean array) representing contraction locations\r\n*/\r\nfunction getContractionIndex( LL, HH, OO, CC )\r\n{\r\n\r\n    // Tunable parameters\r\n    SixMths \t\t\t= 130;\t// Six month limit for previous contraction search (high value within)\r\n    PvtConOSMaxPct\t\t= 0;\r\n\r\n    // rough base data\r\n    HighOfBase\t= LastValue( HHV( HH, SixMths ) );\r\n    HOBBars\t\t= LastValue( HHVBars( HH, SixMths ) )+1;\r\n    LowofBase \t= LastValue( LLV( LL, HOBBars ) );\r\n    LOBBars\t\t= LastValue( LLVBars( LL, HOBBars ) );\r\n\r\n    // remove superfluous swinghighs\r\n    // First pass, remove the obvious ones, not taking lowest lows into account\r\n\r\n    // get preloop values\r\n    SH \t\t\t= SwingHigh( HH );\r\n    \r\n    PPCond\t\t= isPausePivot(LL, HH, OO, CC, SH);\r\n\r\n    for( i = 0; i &lt; BarCount - HOBBars - 1; i++ )\r\n        SH[i] = 0;\r\n        \r\n    LastHigh = LastValue(HH);\r\n    for( i = BarCount - HOBBars; i &lt; BarCount - 1; i++ )\r\n    {\r\n\t\tCurHigh = HH[i];\r\n        if (CurHigh &lt; LastHigh)\r\n\t\t\tSH[i] = 0;\r\n\t\t\t\r\n\t}\r\n\r\n    CurHigh \t= IIf(PPCond, LastValue(HH), HighestHigh( HH, SH, 1 ));\r\n    CurHighBS\t= IIf(PPCond, 0, SwingIndex(\tSH, 1 ));\r\n    // create the filtered output and index counter\r\n    SHfilt \t= SH;\r\n    nth = IIf(PPCond, 1, 2);\r\n\r\n    // loop\r\n    do\r\n    {\r\n        // get previous swinghigh\r\n        NewHigh \t= HighestHigh( HH, SH, nth );\r\n        NewHighBS\t= SwingIndex( SH, nth );\r\n\r\n        // if the new one is lower than the current, kill it, otherwise it's the new current high\r\n        if( CurHigh &gt; Newhigh * ( 1 + PvtConOSMaxPct / 100 ) ) // with overshoot allowance\r\n            SHfilt[BarCount - 1 - NewHighBS] = False;\r\n        else\r\n        {\r\n            CurHigh \t= NewHigh;\r\n            CurHighBS\t= NewHighBS;\r\n        }\r\n\r\n        nth++;\r\n\r\n    }\r\n    while( NewHighBS &lt; HOBBars );\r\n\r\n    //pass 2, remove swing highs taking into account lowest low locations\r\n    // get preloop values\r\n    // high data and low data\r\n    CurHigh \t= HighestHigh( HH, SHfilt, 1 );\r\n    CurHighBS\t= SwingIndex( SHfilt, 1 );\r\n    CurLow  \t= LowestLow( LL, HH, OO, CC, SHfilt, 1 );\r\n    // create index counter and 2nd pass SHfilt\r\n    nth = IIf(PPCond, 1, 2);\r\n    \r\n    SHfiltFinal = SHfilt;\r\n\r\n\t// loop\r\n    if( LastValue(Sum(SHfiltFinal, HOBBars)) &gt; 1  )  // skip if only one contraction exists\r\n    {\r\n        do\r\n        {\r\n            // get previous swinghigh and lowest low\r\n            NewHigh \t= HighestHigh( HH, SHfilt, nth );\r\n            NewHighBS\t= SwingIndex( SHfilt, nth );\r\n            NewLow  \t= LowestLow( LL, HH, OO, CC, SHfilt, nth );\r\n            NewLowBS    = LastValue(LLVBars(Ref(LL, -CurHighBS), NewHighBS) + CurHighBS);\r\n\r\n            // if the current low is lower, the algorithm is still climbing so the current high is not the contraction high\r\n            if( CurLow &lt;= NewLow OR NewLowBS == NewHighBS)\r\n            {\r\n                SHfiltFinal[BarCount - 1 - CurHighBS] = False;\r\n                //CurLow\t\t= LowestLow( LL, HH, OO, CC, SHfilt, nth - 1 ); // need to reset it to the new SHfilt\r\n            }\r\n            else\r\n            {\r\n                CurLow\t\t= LowestLow( LL, HH, OO, CC, SHfilt, nth ); // need to reset it to the new SHfilt\r\n            }\r\n\r\n            // set up next loop\r\n            CurHigh \t= NewHigh;\r\n            CurHighBS\t= NewHighBS;\r\n\r\n            nth++;\r\n        }\r\n        while( NewHighBS &lt; HOBBars AND nth &lt;= LastValue(Sum(SHfilt, BarCount)));\r\n    }\r\n\r\n    ConIndex = SHfiltFinal;\r\n\r\n    return ConIndex;\r\n}\r\n\r\n/* getMSPivotParam Function\r\n\r\n\tPurpose:\r\n\tDetermine if the pivot microstructure is correct and the pivot is valid\r\n\r\n\tReferences:\r\n\t1._CLASSIC_SQUEEZE_PIVOTS_FORMING_ABOVE_THE_TURN_-_Di_Mauro_Perfect_Pivot_thePrivateTrader.com_Pivot.pdf\r\n\r\n\tInput:\tHigh Price Array, Low Price Array, Open Price Array, Close Price Array\r\n\t\t\tInfo string which can equal "Validity" or "Index" or "Price" or "PriceIndex", where:\r\n\t\t\t\tValidity: \t\treturns scalar boolean with validity of the microstructure pivot\r\n\t\t\t\tSwingHighIndex: Returns the SwingHigh Index array of the selected swing high and lowest low of the\r\n\t\t\t\t\t\t\t\tpivot and previous contraction as [Lnth1 Hnth1 Lnth2 Hnth2 ...]\r\n\t\t\t\tPrice: \t\t\tReturns the prices of the selected swing high and lowest low of the\r\n\t\t\t\t\t\t\t\tpivot and previous contraction as [PvtConLow PvtConHigh PrevConLow PrevConHigh...]\r\n\t\t\t\tPriceIndex:\t\tReturns a price array which is zero except for when "Price" occurs". That is,\r\n\t\t\t\t\t\t\t\tif "Price" returns [9 12 10 11 ...], Price Index returns:\r\n\t\t\t\t\t\t\t\t[... 9 ... 12 ... 10 ... 11], where the ellipsis are a padded zeros given their\r\n\t\t\t\t\t\t\t\tdistance between each other.\r\n\t\t\t\t\t\t\t\tThis allows the user to know the location of the prices and the prices for\r\n\t\t\t\t\t\t\t\tfunctions such as plotting\r\n\r\n\t\t\t\t\t\t\t\tNote: all price arrays are size BarCount initialized at zero\r\n\r\n\tOutput: Boolean array indicating true or false\r\n*/\r\nfunction getMSPivotParam( LL, HH, OO, CC, Info )\r\n{\r\n    //// Tunable Parameters\r\n    TolPct\t\t \t\t= 1;\t\t\t\t\t// Set a tolerance to detect marginal conditions\r\n    PvtConSizeMaxPct \t= 6.5 \t + TolPct * 2;\t// Max Pivot Contraction Size\r\n    PvtConOSMaxPct\t\t= 2;\t\t\t\t\t// Max overshoot percent of pivot contraction vs previous\r\n    PrevConSizeMaxPct\t= 16  \t + TolPct * 2;\t// Max Previous Contraction Size\r\n    OverLapMinPct\t\t= 23.6 \t - TolPct * 5;\t// Overlap Min Pct\r\n    OverLapMaxPct\t\t= 61.798 + TolPct * 5;\t// Overlap Max Pct\r\n    PivotHighPct\t\t= 61.798;\t\t\t\t// Pivot High Pct\r\n    PPPrevConLmtPct\t\t= 10\t\t + TolPct * 2;  // Pivot Contraction size limit if there is a pause pivot\r\n    \r\n    // Default Params\r\n    Lnth0 = Null;\t// pause pivot, initially disabled\r\n    Hnth0 = Null;\t// pause pivot, initially disabled\r\n    Lnth1 = 1;\t\t// pivot contraction\r\n    Hnth1 = 1;\t\t// pivot contraction\r\n    Lnth2 = 2;\t\t// previous contraction\r\n    Hnth2 = 2;\t\t// previous contraction\r\n    \r\n\t// get contraction index\r\n\tConIndex = getContractionIndex( LL, HH, OO, CC );\r\n\t\r\n\t// check if previous contraction low is coincident with pivot contraction high\r\n\tPvtConLow\t\t= LowestLow( LL, HH, OO, CC, ConIndex, Lnth1);\r\n\tPvtConLowBars\t= LastValue(BarsSince(LL == PvtConLow));\r\n\tPrevConLow\t\t= LowestLow( LL, HH, OO, CC, ConIndex, Lnth2);\r\n\tPrevConLowBars\t= LastValue(BarsSince(Ref(LL, -PvtConLowBars) == PrevConLow)) + PvtConLowBars;\r\n\t\r\n\t// increment contraction indices if they are coincident\r\n\tif(PvtConLowBars == PrevConLowBars)\r\n\t{\r\n\t\tLnth1--;\r\n\t}\r\n\t\r\n\tPPCond = isPausePivot(LL, HH, OO, CC, ConIndex);\r\n\tif(PPCond)\r\n\t{\r\n\t\t// enable pause pivot\r\n\t\tLnth0 = 0;\r\n\t\tHnth0 = 0;\r\n\t}\r\n\t\telse if (LastValue(Sum(ConIndex, BarCount)) == 1)\r\n\t\t{\r\n\t\t\tLnth1 = 1;\r\n\t\t\tHnth1 = 1;\r\n\t\t\tLnth2 = Null;\r\n\t\t\tHnth2 = Null;\r\n\t\t\t\r\n\t\t\tif (PPCond)\r\n\t\t\t{\r\n\t\t\t\tLnth0 = 0;\r\n\t\t\t\tHnth0 = 0;\r\n\t\t\t}\r\n\t\t\t\r\n\t\t}\r\n\t\t\r\n    \r\n    //// Pivot Contraction Validity\r\n    \r\n    PvtConHigh = HighestHigh(   HH, \t\tConIndex, Hnth1 );\r\n    PvtConLow  = LowestLow( LL, HH, OO, CC, ConIndex, Lnth1 );\r\n    // Measure candidate Pivot Contraction size and validity\r\n    PvtConSize\t\t= ( 1 - PvtConLow / PvtConHigh ) * 100;\r\n    PvtConSizeOK\t= PvtConSize &lt; PvtConSizeMaxPct;\r\n\r\n    // Make sure current bar high is &lt;= pivot high and the close is in the upper 61.978% of the previous upthrust\r\n    CurrBarOK = LastValue( H ) &lt;= PvtConHigh AND LastValue(C) &gt; (1-PivotHighPct/100)*PvtConHigh;\r\n\r\n    // Overall Pivot Contraction Validity\r\n    VldPvtCon = LastValue( PvtConSizeOK AND CurrBarOK );    \r\n    \r\n    // Previous Contraction Validity\r\n\tPrevConHigh = IIf(IsNull(Hnth2), Null, HighestHigh(   HH, \t\t ConIndex, Hnth2  ));\r\n\tPrevConLow  = IIf(IsNull(Lnth2), Null, LowestLow( LL, HH, OO, CC, ConIndex, Lnth2 ));\r\n\t\r\n    // check if pivot contraction high overshoots previous contraction by more than 2%\r\n\tPvtConOSOK\t\t= ( PvtConHigh / PrevConHigh - 1 ) * 100 &lt; PvtConOSMaxPct;\r\n    \r\n    // DERIVED REQT: Exclude undercuts of pivot contraction vs previous contraction\r\n\tPvtConLowOK \t= PvtConLow &gt;= PrevConLow;\r\n\t\r\n\t//// Pause Pivot Contraction Validity\r\n    \r\n    if (PPCond)\r\n    {\r\n\t\tPPConHigh = LastValue(HH);\r\n\t\tPPConLow  = LastValue(LL);\r\n\t\t// Measure candidate Pivot Contraction size and validity\r\n\t\tPPConSize\t\t= ( 1 - PPConLow / PPConHigh ) * 100;\r\n\t\tPPConSizeOK\t\t= PPConSize &lt; PvtConSizeMaxPct;\r\n    } \r\n    else\r\n\t\tPPConSizeOK\t\t= False;\r\n\t\t\r\n\t\t// check that pivot contraction is &lt; 10%\r\n\t\tPPPvtConSizeOK \t= PvtConSize &lt; PPPrevConLmtPct;\r\n\t\t\r\n\tVldPPCon = PPConSizeOK; // AND PPPvtConSizeOK;\r\n\t\r\n\t//// Previous Contraction Validity\r\n\t\r\n\t// Measure candidate Pivot Contraction size\r\n\tPrevConSize\t\t= ( 1 - PrevConLow / PrevConHigh ) * 100;\r\n\t// set to true since we only care about the relative size for previous contraction\r\n\tPrevConSizeOK\t= True; //PrevConSize &lt; PrevConSizeMaxPct;\r\n\r\n\t// Check if the previous contraction is bigger than the pivot contraction\r\n\tConSizeCmpOK = PvtConSize &lt;= PrevConSize;\r\n\t\r\n\tif (NOT ConSizeCmpOK)\r\n\t{\r\n\t\tLnth2 = Null;\r\n\t\tHnth2 = Null;\r\n\t}\r\n\t\r\n\t// Check Overlap\r\n\tif(PPCond)\r\n\t\tOverlapPct\t\t= Overlap( LL, HH, OO, CC, ConIndex, Lnth0, Hnth0, Lnth1, Hnth1);\r\n\telse\r\n\t\tOverlapPct\t\t= Overlap( LL, HH, OO, CC, ConIndex, Lnth1, Hnth1, Lnth2, Hnth2);\r\n\t\t\r\n\t// Check if it's possible to disregard if both contractions are less than PvtConSizeMaxPct\r\n\tDisregardRule \t= (PvtConSize &lt; PvtConSizeMaxPct AND PrevConSize &lt; PvtConSizeMaxPct) OR PPCond;\r\n\t// Check overall overlap conditions\r\n\tOverlapOK \t\t= ( OverlapPct &gt; OverLapMinPct AND OverlapPct &lt; OverLapMaxPct ) OR DisregardRule;\r\n\t\r\n\t// Check Pivot High Rule, i.e. location of the high of the pivot contraction vs prev contraction\r\n\tPHPct\t= ( PvtConHigh - PrevConLow ) / ( PrevConHigh - PrevConLow ) * 100;\r\n\t// Check if within tolerance or if the Disregard rule also applies here\r\n\tPHOK \t= PHPct &gt; ( 100 - PivotHighPct ) OR DisregardRule;\r\n    \r\n    // Check that all conditions for valid pivot are attained\r\n    VldPrevCon = PvtConOSOK + PvtConLowOK + PrevConSizeOK + ConSizeCmpOK + OverlapOK + PHOK &gt;= 6;\r\n    \r\n    // Consolidate all detections\r\n    VldMSPivot = ((VldPPCon AND VldPvtCon) OR (VldPvtCon AND VldPrevCon)) AND LastValue(HH) &lt;= PvtConHigh;\r\n    \r\n    // Return value based on Info input\r\n    \r\n    output[0] = Null; // default if no pause pivot\r\n    output[1] = Null; // default if no pause pivot\r\n    \r\n    switch( Info )\r\n    {\r\n        case "Validity":\r\n            // output is there is a valid pivot\r\n            output = VldMSPivot;\r\n            break;\r\n\r\n        case "SwingHighIndex":\r\n            // output array of indices for the pivot\r\n            output[0] = Lnth0;\r\n            output[1] = Hnth0;\r\n            output[2] = Lnth1;\r\n            output[3] = Hnth1;\r\n            output[4] = Lnth2;\r\n            output[5] = Hnth2;\r\n            break;\r\n\r\n        case "Price":\r\n            // output array of contraction high/low prices\r\n            if(PPCond)\r\n\t\t\t{\toutput[0] = PPConLow;\r\n\t\t\t\toutput[1] = PPConHigh;\r\n\t\t\t}\r\n            output[2] = PvtConLow;\r\n            output[3] = PvtConHigh;\r\n            output[4] = PrevConLow;\r\n            output[5] = PrevConHigh;\r\n            break;\r\n\r\n        case "PriceIndex":\r\n            // output array of contraction high/low prices\r\n            // Pivot Contraction Bars\r\n            PvtConLBar \t= BarCount - 1 - LastValue( BarsSince( LL == PvtConLow ) );\r\n            PvtConHBar \t= BarCount - 1 - SwingIndex( SwingHigh( HH ),   Hnth1 );\r\n\r\n            // Previous contraction Bars\r\n            PrevConLBar = BarCount - 1 - LastValue( BarsSince( LL == PrevConLow ) );\r\n            PrevConHBar\t= BarCount - 1 - SwingIndex( SwingHigh( HH ),   Hnth2 );\r\n\r\n            output[PvtConLBar ]\t= PvtConLow;\r\n            output[PvtConHBar ]\t= PvtConHigh;\r\n            output[PrevConLBar] = PrevConLow;\r\n            output[PrevConHBar] = PrevConHigh;\r\n            \r\n            if (PPCond)\r\n            {\r\n\t\t\t\toutput[BarCount-1] \t= PPConHigh;\r\n\t\t\t\toutput[0]\t\t\t= PPConLow;\r\n            }\r\n            \r\n            break;\r\n    } // end switch\r\n    \r\n    return output;\r\n}\r\n\r\n/* genRS Function\r\n\r\n\tPurpose: Generate the IBD style relative strength\r\n\r\n\tReferences:\r\n\thttps://forum.amibroker.com/t/how-to-imitate-ibd-relative-strength-percentile-ranking-of-stocks/\r\n\tAuthor: Michael Angelo MUSTILLO (rocketPower)\r\n\r\n\tInput:\tN/A, it will use Amibroker market lists for NYSE and NASDAQ\r\n\tOutput: Function has no output but will store static variables with the following naming structure:\r\n\t\t\tRS_&lt;Ticker&gt;, e.g. RS_GOOG, with a data format of a percentile value from 0-99\r\n*/\r\nfunction genRS()\r\n{\r\n    // Default value for average days in three months of trading\r\n    ThreeMth = 63;\r\n\r\n    // Collect symbols from all markets\r\n    listNYSE = CategoryGetSymbols( categoryMarket, 1  );\t// NYSE\r\n    listNSDQ = CategoryGetSymbols( categoryMarket, 2  );\t// NASDAQ\r\n    listARCA = CategoryGetSymbols( categoryMarket, 3  );\t// NYSE ARCA\r\n    listNYAM = CategoryGetSymbols( categoryMarket, 4  );\t// NYSE American\r\n    listCBZX = CategoryGetSymbols( categoryMarket, 5  );\t// CBOE BZX\r\n\r\n    // Create the full list of stocks to be ranked as a concatenated string CSV of both markets\r\n    List    = listNYSE + "," + listNSDQ + "," + listARCA + "," + listNYAM + "," + listCBZX;\r\n    ListQty = StrCount( List, "," ) + 1;\r\n\r\n    // Clear the static vars from last run\r\n    StaticVarRemove( "*" );\r\n\r\n    // Generate the raw RS score for every stock and store in a static var\r\n    for( n = 0; ( Symbol = StrExtract( List, n ) ) != "";  n++ )\r\n    {\r\n        // Set price arrays to current symbol in the loop\r\n        SetForeign( Symbol );\r\n\r\n        // Calculate Raw RS\r\n        if( BarCount &gt; ThreeMth * 4 )\r\n        {\r\n            x1 = ROC( C, ThreeMth * 1 );\r\n            x2 = ROC( C, ThreeMth * 2 );\r\n            x3 = ROC( C, ThreeMth * 3 );\r\n            x4 = ROC( C, ThreeMth * 4 );\r\n\r\n            // Aggregate raw score\r\n            RSRaw = 2 * x1 + x2 + x3 + x4;\r\n\r\n            // set to static var\r\n            StaticVarSet( "RSRaw_" + Symbol, RSRaw );\r\n        }\r\n        else\r\n            if( BarCount &gt; ThreeMth * 3 )\r\n            {\r\n                x1 = ROC( C, ThreeMth * 1 );\r\n                x2 = ROC( C, ThreeMth * 2 );\r\n                x3 = ROC( C, ThreeMth * 3 );\r\n                x4 = ROC( C, BarCount - 1 );\r\n\r\n                // Aggregate raw score\r\n                RSRaw = 2 * x1 + x2 + x3 + x4;\r\n\r\n                // set to static var\r\n                StaticVarSet( "RSRaw_" + Symbol, RSRaw );\r\n            }\r\n            else\r\n                if( BarCount &gt; ThreeMth * 2 )\r\n                {\r\n                    x1 = ROC( C, ThreeMth * 1 );\r\n                    x2 = ROC( C, ThreeMth * 2 );\r\n                    x3 = ROC( C, BarCount - 1 );\r\n                    x4 = ROC( C, BarCount - 1 );\r\n\r\n                    // Aggregate raw score\r\n                    RSRaw = 2 * x1 + x2 + x3 + x4;\r\n\r\n                    // set to static var\r\n                    StaticVarSet( "RSRaw_" + Symbol, RSRaw );\r\n                }\r\n                else\r\n                    if( BarCount &gt; ThreeMth )\r\n                    {\r\n                        x1 = ROC( C, ThreeMth * 1 );\r\n                        x2 = ROC( C, BarCount - 1 );\r\n                        x3 = ROC( C, BarCount - 1 );\r\n                        x4 = ROC( C, BarCount - 1 );\r\n\r\n                        // Aggregate raw score\r\n                        RSRaw = 2 * x1 + x2 + x3 + x4;\r\n\r\n                        // set to static var\r\n                        StaticVarSet( "RSRaw_" + Symbol, RSRaw );\r\n                    }\r\n                    else\r\n                        if( BarCount &gt; 3 )\t\t// Amibroker complains it needs 3 bars for charts\r\n                        {\r\n                            x1 = ROC( C, BarCount - 1 );\r\n                            x2 = ROC( C, BarCount - 1 );\r\n                            x3 = ROC( C, BarCount - 1 );\r\n                            x4 = ROC( C, BarCount - 1 );\r\n\r\n                            // Aggregate raw score\r\n                            RSRaw = 2 * x1 + x2 + x3 + x4;\r\n\r\n                            // set to static var\r\n                            StaticVarSet( "RSRaw_" + Symbol, RSRaw );\r\n                        }\r\n                        else\r\n                        {\r\n                            // Don't consider in percentile ranking\r\n                            ListQty--;\r\n\t\t\t\t\t\t}\r\n\r\n        // Reset price arrays\r\n        RestorePriceArrays();\r\n    }\r\n\r\n    StaticVarGenerateRanks( "Rank", "RSRaw_", 0, 1234 );\r\n    // Generate ranking of results\r\n\r\n    // Convert the static var ranks generated into a percentile score.\r\n    for( n = 0; ( Symbol = StrExtract( List, n ) )  != "";  n++ )\r\n    {\r\n        // get the current symbol's RSRaw_ value\r\n        Rank  = StaticVarGet( "Rank" + "RSraw_" +  Symbol );\r\n\r\n        // create percentile value IBD-style\r\n        RSpctile = 100 - 100 * Rank / ListQty;\r\n        \r\n        // alternate percentile rank formula\r\n        RSpctile = floor((ListQty - Rank)/ListQty*100);\r\n\r\n        // store the IBD style ranking in new static variable named "RS_&lt;Ticker&gt;"\r\n        StaticVarSet( "RS_" + Symbol, RSpctile, True );\r\n    }\r\n\r\n    // remove unnecessary static data\r\n    // free up old stuff\r\n    StaticVarRemove( "RSraw_*" );\r\n    StaticVarRemove( "Rank" + "RSraw_*" );\r\n    \r\n    return ListQty;\r\n}\r\n\r\n/* TrendFilter Function\r\n\r\n\tPurpose: Determine if stock meet Stage 2 Criteria\r\n\r\n\tReferences:\r\n\tMark Minervini - How to Trade Like a Stock Market Wizard (Trend Template)\r\n\tTPT Discord Server #scanning-criteria, #trend-template\r\n\thttps://media.discordapp.net/attachments/776626855791951883/778750306045526036/unknown.png?width=1187&amp;height=471\r\n\r\n\tInput:\tClose price and Volume arrays, static var with Relative Strength generated with genRS function (needs to run before!)\r\n\tOutput: Scalar Boolean\r\n*/\r\nfunction TrendFilter( LL, HH, OO, CC, VV )\r\n{\t\r\n\tOneMth = 21;  // days\r\n\t\r\n\t// get non-null range (supports rewind)\r\n\tRange = LastValue(BarsSince(IsNull(CC)))-1;\r\n\tif(Range &lt; 0)\r\n\t\tRange = BarCount;\r\n\t\r\n\tif(Range &gt; OneMth*12)\r\n\t{\r\n\t\t// Get moving averages\r\n\t\tSMA200 \t\t= MA(  CC, 200 );\r\n\t\tSMA150 \t\t= MA(  CC, 150 );\r\n\t\tSMA050 \t\t= MA(  CC,  50 );\r\n\t\tHigh52pct \t= HHV( CC, 253 );\r\n\t\tLow52pct\t= LLV( CC, 253 );\r\n\t\tSMAV50\t\t= MA(  VV,  50 );\r\n\t\t\r\n\t\t// Average Dollar volume of past 50 day\r\n\t\tDolVol\t\t= CC*SMAV50;\r\n\t\t\r\n\t\t// determine price from low over last year to high within max baselen\r\n\t\tROCLow\t\t= LLV( LL, 253 );\r\n\t\tROCHigh\t\t= HHV( HH, 130 );\r\n\t\t\r\n\t\tROC12M\t\t= (ROCHigh/RocLow-1)*100; // get the lowest price in the past year to calc ROC\r\n\t\t\r\n\t\t// get RS value\t\t\r\n\t\tRS          = StaticVarGet("RS_" + Name());\t\t// run genRS to update this!!!\r\n\t\t\r\n\t\tATR30\t\t= (ATR(30)/C)*100;\r\n\t\t\r\n\t\t// Trend filter logic taken from TPT Discord #scanning-criteria channel\r\n\t\tx1 = True; //CC\t     \t&gt; 15;\r\n\t\tx2 = CC      \t&gt; High52pct*0.75;\r\n\t\tx3 = RS     \t&gt; 84;\r\n\t\tx4 = SMAV50 \t&gt; 5e4;\r\n\t\tx5 = ROC12M\t\t&gt; 30;\r\n\t\tx6 = DolVol\t\t&gt; 1e7;\r\n\t\tx7 = True; //ATR30      &lt; 7;\r\n\t\t\r\n\t\tx8  = CC  \t &gt; SMA150;\r\n\t\tx9  = CC \t &gt; SMA200;\r\n\t\tx10 = SMA150 &gt; SMA200;\r\n\t\tx11 = SMA200 &gt; Ref(SMA200, -21);\r\n\t\tx12 = SMA050 &gt; SMA150;\r\n\t\tx13 = SMA050 &gt; SMA200;\r\n\t}\r\n\telse\t// IPO\r\n\t{\t\t\r\n\t\t// Get moving averages\r\n\t\tSMA200 \t\t= MA(  CC, 200 );\r\n\t\tSMA150 \t\t= MA(  CC, 150 );\r\n\t\tSMA050 \t\t= MA(  CC,  50 );\r\n\t\tHigh52pct \t= HHV( CC, 253 );\r\n\t\tLow52pct\t= LLV( CC, 253 );\r\n\t\tSMAV50\t\t= MA(  VV,  50 );\r\n\t\t\r\n\t\t// Average Dollar volume of past 50 day\r\n\t\tRawDolVol\t= CC*MA(VV, Range);\r\n\t\tDolVol\t\t= IIf(IsEmpty(SMAV50), RawDolVol, CC*SMAV50);\r\n\t\t\r\n\t\t// determine price from low over last year to high within max baselen\r\n\t\tROCLow\t\t= LLV( LL, 253 );\r\n\t\tROCHigh\t\t= HHV( HH, 130 );\r\n\t\t\r\n\t\tROC12M\t\t= (ROCHigh/RocLow-1)*100; // get the lowest price in the past year to calc ROC\r\n\t\t\r\n\t\t\r\n\t\tATR30\t\t= (ATR(Min(30, Range))/C)*100;\r\n\t\t\r\n\t\t// Trend filter logic taken from TPT Discord #scanning-criteria channel\r\n\t\tx1 = True;  //CC\t     \t&gt; 15;\r\n\t\tx2 = CC      \t&gt; High52pct*0.75;\r\n\t\tx3 = True;\t// disable RS Check\r\n\t\tx4 = SMAV50 \t&gt; 5e4 OR IsEmpty(SMAV50);\r\n\t\tx5 = ROC12M\t\t&gt; 30;\r\n\t\tx6 = DolVol\t\t&gt; 2.5e7;\r\n\t\tx7 = True;  //ATR30      &lt; 7;\r\n\t\t\r\n\t\t// attempt these if moivng avg exists\r\n\t\tx8  = CC  \t &gt; SMA150 OR IsEmpty(SMA150);\r\n\t\tx9  = CC \t &gt; SMA200 OR IsEmpty(SMA200);\r\n\t\tx10 = SMA150 &gt; SMA200 OR IsEmpty(SMA200);\r\n\t\tx11 = SMA200 &gt; Ref(SMA200, -21) OR IsEmpty(SMA200) OR BarCount &lt; 221;\r\n\t\tx12 = SMA050 &gt; SMA150 OR IsEmpty(SMA150);\r\n\t\tx13 = SMA050 &gt; SMA200 OR IsEmpty(SMA200);\r\n\t}\r\n\t\r\n\t\r\n\tTF = x1 AND x2 AND x3 AND x4 AND x5 AND x6 AND x7 AND x8 AND x9 AND x10 AND x11 AND x12 AND x13;\r\n\t\r\n\treturn TF;\r\n}\r\n\r\n/* getTurnLA Function\r\n\r\n\tPurpose: Determine the turn line array\r\n\r\n\tReferences:\r\n\t2._CLASSIC_EARLY_SQUEEZE_PIVOTS_FORMING_AT_THE_TURN_-_Di_Mauro_Perfect_Pivot_thePrivateTrader.com_Pi.pdf\r\n\r\n\tInput:\tLow and High price arrays\r\n\tOutput: Price array representing the turn line equation\r\n*/\r\nfunction getTurnLA( LL, HH, OO, CC )\r\n{\r\n\r\n    // get CS base data, should work with Power play data as well\r\n    if( getCSBaseParam( LL, HH, OO, CC, "Validity" ) )\r\n    {\r\n        LHSPrice  \t= getCSBaseParam( LL, HH, OO, CC, "LHSPrice"\t);\r\n        LHSBars  \t= getCSBaseParam( LL, HH, OO, CC, "LHSBars"\t);\r\n        LowPrice  \t= getCSBaseParam( LL, HH, OO, CC, "LowPrice"\t);\r\n    }\r\n    else\r\n        if( getPPBaseParam( L, H, "Validity" ) )\r\n        {\r\n            LHSPrice  \t= getPPBaseParam( L, H, "PoleHigh"\t);\r\n            LowPrice\t= getPPBaseParam( L, H, "FlagLow"\t);\r\n            LHSBars  \t= getPPBaseParam( L, H, "PHBar"\t);\r\n            //PoleLow  \t= getPPBaseParam( L, H, "PoleLow"\t);\r\n            //PoleLen  \t= getPPBaseParam( L, H, "PoleLen"\t);\r\n\r\n        }\r\n        else\r\n        {\r\n            LHSPrice  \t= 0;\r\n            LowPrice\t= 0;\r\n            LHSBars  \t= 0;\r\n        }\r\n\r\n    //// calculate turn\r\n    nth = 1;\r\n\r\n    // get nth swinghigh value for baselow\r\n    SH = SwingHigh(HH);\r\n    while( HighestHigh( HH, SH, nth ) != LHSPrice)\r\n\t\tnth++;\r\n\r\n    // get initial candidate top of turn coordinates\r\n    TurnTopP \t= LHSPrice;\r\n    TurnTopB \t= LastValue( BarsSince( HH == LHSPrice ) );\r\n\r\n    // get initial candidate bottom of turn coordinates\r\n    TurnBotP = HighestHigh( HH, SH, nth );\r\n    TurnBotB = LastValue( BarsSince( HH == TurnBotP ) );\r\n\r\n    // Calculate if TurnLA is valid\r\n    LowPriceBars  = LastValue( BarsSince( LL == LowPrice ) );\r\n    HighPriceBars = LastValue( BarsSince( HH == LHSPrice ) );\r\n\r\n    InLHS = BarIndex() &gt;= BarCount - 1 - HighPriceBars AND BarIndex() &lt;= Barcount - 1 - LowPriceBars;\r\n\r\n    // if there is no swing high in the lhs of base set to high of base low day\r\n    if( TurnBotP == LHSPrice )\r\n    {\r\n        TurnBotP = H[BarCount - 1 - LowPriceBars];\r\n        TurnBotB = LastValue( BarsSince( HH == TurnBotP ) );\r\n    }\r\n\r\n    // Calculate the candidate Turn Line with full extend left and right\r\n    TurnLA\t= LineArray( BarCount - 1 - TurnTopB, TurnTopP, BarCount - 1 - TurnBotB, TurnBotP, 3 );\r\n\r\n    CrossTurn = HH &gt; TurnLA;\r\n\r\n    // Check if there's a bad cross of H over TurnLA\r\n    BadCrossDetect = InLHS AND CrossTurn;\r\n\r\n    // Find location of largest excursion\r\n    Excursion \t= IIf( BadCrossDetect, HH - TurnLA, Null );\r\n    ExcBars\t\t= LastValue( HHVBars( Excursion, LHSBars ) );\r\n\r\n    // detect if the line doesn't meet the requirements\r\n    BadLine\t\t= LastValue( Cum( BadCrossDetect ) );\r\n\r\n    // Set the new coordinates depending on where the excursion is\r\n    if(\tTurnTopB - ExcBars &lt; ExcBars - TurnBotB AND BadLine )\r\n    {\r\n        // perform this fix if the error is closer to the top\r\n        TurnTopB = ExcBars;\r\n        TurnTopP = HH[BarCount - 1 - TurnTopB];\r\n    }\r\n    else\r\n        if( BadLine )\r\n        {\r\n            // perform this fix if the error is closer to the bottom\r\n            TurnBotB = ExcBars;\r\n            TurnBotP = HH[BarCount - 1 - TurnBotB];\r\n\r\n        }\r\n\r\n    // Calculate the candidate Turn Line with full extend left and right\r\n    TurnLA\t= LineArray( BarCount - 1 - TurnTopB, TurnTopP, BarCount - 1 - TurnBotB, TurnBotP, 3 );\r\n\r\n    // format linearray for plotting\r\n    TurnLA  = IIf( BarIndex() &gt; BarCount - 2 - LastValue( BarsSince( HH == LHSPrice ) ) AND BarIndex() &lt; BarCount, TurnLA, Null );\r\n    TurnLA  = IIf( TurnTopP &lt;= TurnBotP, Null, TurnLA );\r\n\t\r\n\tTurnLASlopeOK = TurnLA[BarCount-1]/TurnLA[BarCount - 1 - HighPriceBars] &lt; 1;\r\n\t\r\n\tif (NOT TurnLASlopeOK)\r\n\t\tTurnLA = Null;\r\n\r\n    // return output\r\n    return TurnLA;\r\n}\r\n\r\n/* getPPPivotParam Function\r\n\r\n\tPurpose: Determine alternate pivot detection for power squeezes\r\n\r\n\tReferences:\r\n\tTPT Discord channel #perfect-pivot-microstructure\r\n\tPower_Squeeze_Setup_Rules_v1.1.pdf\r\n\r\n\tInput:\tLow and High close and Vol price arrays, Power squeeze parameters, flag low price, pole high price, turn line price array, pivot high price\r\n\tOutput: 0 = no possible pivot, 1 = hourly pivot possible, 2 = daily chart pivot valid\r\n*/\r\nfunction getPPPivotParam( LL, HH, CC, VV, FlagLow, PoleHigh, TurnLA, PvtH, PivotHigh )\r\n{\r\n    // tunables\r\n    UpMoveMaxPct \t\t= 16;\r\n    PivotHeightMaxPct \t= 8;\r\n    PivotHighPct\t\t= 61.798;\r\n    FlatBaseLimPct\t\t= 16;\r\n\r\n    // Find if close is above turn line and where the turn occurred\r\n    CAT \t= LastValue( CC &gt; TurnLA );\r\n    CATBar\t= LastValue( BarsSince( Cross( CC, TurnLA ) ) );\r\n\t\t\r\n\t// bars since the low of flag\r\n    FlagLowBars = LastValue( BarsSince( LL == FlagLow ) );\r\n\r\n\tUpMoveOK \t  = False;\r\n\tFlatBaseValid = False; \r\n\t\r\n    if( CAT )\r\n    {\r\n        // get % move of the upmove after the turn\r\n        UpMoveHigh = LastValue( HHV( HH, CATBar + 1 ) );\r\n        UpMoveBar  = LastValue( HHVBars( HH, CATBar ) );\r\n\r\n        // location of upmove low (low of flag or swing low later?)\r\n        UpMoveLowCand = LastValue( LLV( LL, LLVBars( LL, FlagLowBars + 1 ) ) );\r\n\r\n        // find the upmove price low\r\n        if( UpMoveLowCand &gt; FlagLow )\r\n            UpMoveLow = UpMoveLowCand;\r\n        else\r\n            UpMoveLow = FlagLow;\r\n            \r\n        // calculate the upmove percent change and validity\r\n\t\tUpMovePct  = ( UpMoveHigh / UpMoveLow - 1 ) * 100;\r\n\t\tUpMoveOK   = UpMovePct &lt; UpMoveMaxPct;\r\n\t}\r\n\telse // flag is a flat base\r\n\t\t{\r\n\t\t\tFlagHeightPct = (1 - FlagLow/PoleHigh)*100;\r\n\t\t\tFlatBaseValid = FlagHeightPct &lt;= FlatBaseLimPct;\r\n\t\t}\r\n\t\t\r\n\t// determine if pivot is in the right location within the base\r\n    // get pivot height relative to bottom of turn\r\n    PHPct\t= ( PivotHigh - FlagLow ) / ( PoleHigh - FlagLow ) * 100;\r\n    // remove possibility that low of contraction is the possible hourly pivot\r\n    //LBC\t\t= LastValue(CC);\r\n    //LBHPct  = ( LBC       - FlagLow ) / ( PoleHigh - FlagLow ) * 100;\r\n    PHOK \t= PHPct &gt; ( 100 - PivotHighPct );// AND LBHPct &gt; ( 100 - PivotHighPct );\r\n        \r\n    // format and set output\r\n    if (LastValue(HH) &lt;= PivotHigh AND PvtH &lt; PivotHeightMaxPct AND (CAT OR FlatBaseValid) AND PHOK AND (FlatBaseValid OR UpMoveOK))\r\n\t\toutput = 2;\r\n\telse\r\n\t\tif (LastValue(HH) &lt;= PivotHigh AND (FlatBaseValid OR UpMoveOK) AND PHOK)\r\n\t\t\toutput = 1;\r\n\t\telse\r\n\t\t\toutput = 0;\r\n\t\t\t\r\n    return output;\r\n}\r\n\r\nfunction checkVolume(CC, VV, ConIndex, LHSBars)\r\n{\r\n\t// average volume over 50 days\r\n\tVolMA = MA(V, 50);\r\n\t\r\n\t// get the number of bars since the start of the last contraction\r\n\tPvtConBars = LastValue(BarsSince(ConIndex == True));\r\n\t\t\r\n\t//// VOLUME DRYUP \r\n\t\r\n\t// check if there are any bars in the pivot contraction whose volume is &lt; 50% of the highest volume in the base)\r\n\t// this will set to false any index before the pivot contraction, and then check the volume condition on the rest\r\n\tVolBar50   = Cum(BarIndex() &gt; BarCount - 1 - PvtConBars AND VV &lt; 0.5*LastValue(HHV(VV, LHSBars)));\r\n\t\r\n\t// If the sum is greater than 0, the volume condition is confirmed (event occurred at least once in the pivot contraction)\r\n\tVolBar50OK = VolBar50 &gt; 0;\r\n\t\r\n\t// repeat the same process but check if a volume bar in the pivot contraction was 65% or less than the average volume\r\n\tVolBar65   = Cum(BarIndex() &gt; BarCount - 1 - PvtConBars AND VV &lt; 0.65*LastValue(VolMa));\r\n\t\r\n\t// If the sum is greater than 0, the volume condition is confirmed (event occurred at least once in the pivot contraction)\r\n\tVolBar65OK = VolBar65 &gt; 0;\r\n\t\r\n\t//// EVIDENCE OF ACCUMULATION\r\n\tUpday = CC &gt; Ref(CC, -1);\r\n\t\r\n\t// check for 150% vol bars in base, in at least 3 vol bars\r\n\tVolAcc5050   = Cum(BarIndex() &gt; BarCount - 1 - LHSBars AND VV &gt; 1.5*VolMa AND Upday);\r\n\tVolAcc5050OK = VolAcc5050 &gt; 2;\r\n\t\r\n\t// check for 25mil dollarvolume day in base\r\n\tVolDol25M    \t= Cum(BarIndex() &gt; BarCount - 1 - LHSBars AND CC*VV &gt; 2.5e7 AND Upday);\r\n\tVolDolVol25MOK\t= VolDol25M &gt; 0;\r\n\t\r\n\t// overall volume health\r\n\tVolOK    = False;\r\n\tVolOK[0] = LastValue( VolBar50OK   AND VolBar65OK     );\r\n\tVolOK[1] = LastValue( VolAcc5050OK AND VolDolVol25MOK );\r\n\t\t\r\n\treturn VolOK;\t\r\n}\r\n\r\n\r\n//EOF\r\n</Formula>
		</File>
	</Includes>
</Window>
